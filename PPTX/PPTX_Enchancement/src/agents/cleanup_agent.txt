# from fastapi import FastAPI
# from fastapi.middleware.cors import CORSMiddleware
# import requests
# import base64
# import os
# import json

# app = FastAPI()

# # CORS setup (optional for frontend integration)
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# LLM_API_KEY = "AIzaSyAv0sTw83EOKcJtoSyT9ug4cnzwGagkMJY"
# GEMINI_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={LLM_API_KEY}"


# ENHANCED_PROMPT = """
# You are a PowerPoint slide layout and structure analysis assistant using Office.js-compatible metadata and a slide screenshot.

# You are given two inputs:
# 1. An image of the slide (screenshot).
# 2. A metadata JSON object for all slide shapes. Each shape has: 
#    - id, name, type, top, left, width, height, z-index, text, isGrouped, overlapsWith

# Your job is to detect layout and design issues **based on BOTH the visual image and metadata** — and suggest precise, implementable fixes. Do NOT make assumptions without data support.

# ---

# ### Step-by-Step Instructions (strict)

# ---

# ### Step 0: Cross-Verify Visual vs Metadata Observations
# - If image-detected layout issues (e.g. from Gemini/Vision) are available, list them first.
# - For **each issue**, verify it against the metadata numerically (check `top`, `left`, etc.).
# - Mark visually flagged issues as **confirmed** or **disproved** using metadata.
# - If confirmed, proceed with fix suggestions.
# - If disproved, state that too with justification.

# ---

# ### Step 1: Detect Off-Slide Elements (960x540 canvas)

# - Identify any shapes extending beyond the slide boundaries (either horizontally or vertically).
# - If a **single shape** overflows:
#   - If space exists: move it left or upward to fit.
#   - If space is tight: reduce width or height proportionally to fit within bounds.
# - If **multiple shapes in a row or column** are involved (e.g., a horizontal row where the last shape spills out):
#   - Treat them as a **group**.
#   - Calculate the total overflow and **resize all group elements equally and proportionally**.
#   - Maintain alignment, spacing, and visual balance across the group.
# - Ensure no visual cropping or distortion occurs and layout integrity is preserved.

# ---

# ### Step 2: Detect Layout Inconsistencies (must execute fully)

# - **Misalignment**:
#   - Elements meant to align (based on visual or naming patterns) but with different `left` or `top`.
#   - Example: `Shape 512` and `Shape 464` both on same row but top differs.
#   - Fix: Align top/left to reference shape. Include value.

# - **Overlapping elements**:
#   - Check `overlapsWith` property.
#   - If shapes are not grouped, report as layout error.
#   - Fix: Move overlapping shape or group them.

# - **Inconsistent sizes**:
#   - Shapes of same type/role (e.g. multiple text boxes for points) but different width/height.
#   - Normalize to common size and document values.

# - **Z-index issues**:
#   - Shape is visually blocked and its `z-index` is lower than overlapping shapes.
#   - Fix: Increase `z-index` (give new value).


# For each issue, include:
# - Shape IDs and positions
# - Specific alignment/sizing/z-index fix (e.g., "Set shape 480's top to match shape 474 at 120px")

# ---

# ### Step 3: Design Consistency Checks
# Inspect:
# - Font inconsistencies in text shapes with similar roles (e.g., two bullet points with different font sizes or alignment)
# - Elements that should be aligned to an invisible grid (e.g., icons slightly misaligned in a row or column)
# - Connector lines: Are they disconnected or not attached to their source/destination?
# - Grouped elements: Are they grouped logically? If not, suggest grouping

# ---

# ### Step 4: Row/Column Analysis
# Detect if shapes are visually aligned as a row or column:
# - In a row: `top` values should be approximately equal, and spacing (`left`) should be consistent
# - In a column: `left` values should match, spacing (`top`) should be regular
# - For each group:
#   - Suggest fixing misalignments
#   - Ensure same font size, alignment, and formatting if it's text

# ---

# ### Output Format (strict):
# - Use bullet points grouped by step
# - Each point must include:
#   - Shape `id`, `name`, and type
#   - Action to fix (with actual values, like `left = 220` or `zIndex = 4`)
# - Avoid generic suggestions like “looks bad” or “seems off”
# - Do not make assumptions without metadata support

# You must combine visual (image) and metadata analysis for accurate diagnostics.

# ---
# """



# @app.get("/analyze-slide")
# def analyze_slide():
#     image_path = "slide_images/image.png"
#     # image_path = "slide_images/images/presentation/slide_1.png"
#     metadata_path = "slide_images/metadata.json"

#     if not os.path.exists(image_path):
#         return {"error": "Slide image not found."}
#     if not os.path.exists(metadata_path):
#         return {"error": "Metadata JSON not found."}

#     try:
#         with open(image_path, "rb") as img_file:
#             base64_img = base64.b64encode(img_file.read()).decode("utf-8")
#         with open(metadata_path, "r", encoding="utf-8") as json_file:
#             metadata_content = json.load(json_file)
#             metadata_str = json.dumps(metadata_content, indent=2)
#     except Exception as read_err:
#         return {"error": f"File read error: {read_err}"}

#     payload = {
#         "contents": [
#             {
#                 "parts": [
#                     {"text": ENHANCED_PROMPT},
#                     {
#                         "inline_data": {
#                             "mime_type": "image/png",
#                             "data": base64_img
#                         }
#                     },
#                     {
#                         "text": f"Here is the shape metadata (JSON):\n\n{metadata_str}"
#                     }
#                 ]
#             }
#         ]
#     }

#     response = requests.post(GEMINI_URL, json=payload)
#     if response.status_code != 200:
#         return {"error": f"Gemini API Error: {response.text}"}

#     try:
#         output = response.json()["candidates"][0]["content"]["parts"][0]["text"]
#         return {"analysis": output}
#     except Exception as e:
#         return {"error": f"Invalid response from Gemini: {e}"}











import json
import os
import base64
import requests
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# CORS setup (optional for frontend integration)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

LLM_API_KEY = "AIzaSyAv0sTw83EOKcJtoSyT9ug4cnzwGagkMJY"
GEMINI_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={LLM_API_KEY}"

LAYOUT_ANALYSIS_PROMPT = """You are an expert AI assistant analyzing a PowerPoint slide to detect and resolve layout and design issues with minimal disruption to the existing layout. Your goal is to identify and resolve overflow (horizontal and vertical), misalignment, overlap, and inconsistent sizing among shapes, while being mindful of the element's surroundings and avoiding significant positional changes. Additionally, detect table-like layouts and suggest grid-based alignment where appropriate.

**Input:**
- Slide Image: A screenshot of the slide (for visual reference).
- Shape Metadata (JSON): An array of shape objects containing:
  - id, name, type, top, left, width, height, zIndex, text, isGrouped, overlapsWith

---

**1. Overflow Detection & Strict Resolution (No Overflow Allowed)**

**Slide boundaries:** width = `960px`, height = `540px`

**Horizontal Overflow (Right Edge):**
- For each shape, if `left + width >= 960`:
  - Identify its **row**: other shapes with `top` within ±10px.
  - Compute:
    - `row_min_left = min([s['left'] for s in row_shapes])`
    - `row_max_right = max([s['left'] + s['width'] for s in row_shapes])`
    - `row_width = row_max_right - row_min_left`
    - `horizontal_overflow = row_max_right - 960`
    - `width_scale_factor = (row_width - horizontal_overflow) / row_width`
      - If `width_scale_factor >= 0.7`, proceed with **proportional resizing**:
        - **Instruction**: "For shapes (ids: {row_ids}), proportionally resize to fit within slide by setting `width` to `original_width * {width_scale_factor:.2f}`, `height` to `original_height * {width_scale_factor:.2f}`, and `left` to `{row_min_left} + ((original_left - {row_min_left}) * {width_scale_factor:.2f})` to resolve right overflow."
      - Else:
        - `uniform_width_reduction = horizontal_overflow / len(row_shapes)`
        - **Instruction**: "Reduce `width` of shapes (ids: {row_ids}) uniformly by `{uniform_width_reduction:.2f}`px and adjust `left` by `original_left - (original_left - {row_min_left}) * ({uniform_width_reduction:.2f} / {row_width})` to preserve relative spacing and resolve right overflow."
      - **Crucially:** If even uniform reduction doesn't fully resolve overflow without extreme shrinkage (scale_factor < 0.6), consider a very minor left shift (<= 10px) of the entire row in conjunction with resizing. Document this carefully.

**Vertical Overflow (Bottom Edge):**
- If `top + height >= 540`:
  - Identify **column**: shapes with `left` within ±10px.
  - Apply similar logic as horizontal overflow, adjusting `top` and `height`.

---

**2. Layout Consistency Fixes (Aware of Surroundings & Limited Movement)**

**A. Misalignment in Rows/Columns:**
- Group into **rows** and **columns**.
- For each group:
  - Identify a well-positioned "anchor" shape (e.g., the first or largest).
  - For other shapes with `top` or `left` differing by > 5px from the anchor:
    - If adjustment to match anchor is within 10px of original:
      - **Instruction**: "Align shape '{misaligned_id}' by setting `top` (or `left`) to {anchor_top}px (or {anchor_left}px) to align with '{anchor_id}'."
    - Else, suggest the *minimal* adjustment needed to reduce the difference, not exceeding 10px.

**B. Overlapping Shapes (Not Grouped):**
- For each shape with `overlapsWith`:
  - If not `isGrouped`, and collision can be fixed with ≤10px shift:
    - Determine the direction of minimal shift (horizontal or vertical).
    - **Instruction**: "Shift shape '{overlapping_id}' by {shift_amount:.2f}px on `left` (or `top`) to avoid overlap with '{other_id}'."
  - If a small shift isn't enough, consider very minor proportional resizing (scale factor >= 0.95) of the overlapping shapes.

**C. Inconsistent Size (Same Type/Role, Aware of Row/Column):**
- For shapes in the same row/column with similar `name` or `type`:
  - Calculate the median `width` and `height`.
  - For shapes deviating by > 10% from the median:
    - If adjustment to median is small (<= 10% change in dimension):
      - **Instruction**: "Adjust `width` (or `height`) of shape '{id}' to {median_value:.2f}px to improve size consistency within the {row/column}."

---

**3. Table Layout Detection & Grid Alignment**

- **Detect Table-like Structure:** Identify groups of shapes that:
  - Are mostly rectangular or text placeholders.
  - Are arranged in clear rows and columns (consistent `top` and `left` alignments with regular spacing).
  - Have similar `height` within rows and similar `width` within columns.
- If a table-like structure is detected:
  - Identify the boundaries of the "grid" (min/max `left`, min/max `top`, number of rows/columns, average spacing).
  - For shapes within the identified table:
    - **Instruction**: "Align shapes (ids: [...]) to the detected table grid with column widths {col_widths} and row heights {row_heights}, adjusting `left` and `top` accordingly for precise alignment." (This would require calculating the grid dimensions and suggesting new `left` and `top` values based on cell indices).

---

**4. Text Alignment Consistency (Metadata-limited)**

- For text boxes in a row/column with similar content:
  - If `textAlign` differs:
    - Suggest aligning to the most frequent `textAlign` with a minor adjustment if needed.

---

**5. General Principles & Output Format:**

- **Strictly prevent any overflow.**
- Prioritize **proportional resizing** for overflow, with minor shifting as a last resort.
- Maintain **relative positions** within groups.
- Avoid **significant movement** from original positions (limit to ~10px for minor adjustments).
- Be **aware of the surrounding elements** when suggesting changes to avoid creating new issues.
- **Detect and utilize grid alignment** for table-like layouts.
- For every fix, provide clear **Office.js-compatible instructions** including what to change, why, and how (values, scale factors, shift amounts, grid information).
- Format each fix as a clear **natural language instruction**.
"""

@app.get("/analyze-slide")
def analyze_slide():
    # image_path = "slide_images/image.png"
    image_path = "slide_images/images/presentation/slide_1.png"
    metadata_path = "slide_images/metadata.json"

    if not os.path.exists(image_path):
        return {"error": "Slide image not found."}
    if not os.path.exists(metadata_path):
        return {"error": "Metadata JSON not found."}

    try:
        with open(image_path, "rb") as img_file:
            base64_img = base64.b64encode(img_file.read()).decode("utf-8")
        with open(metadata_path, "r", encoding="utf-8") as json_file:
            metadata_content = json.load(json_file)
            metadata_str = json.dumps(metadata_content, indent=2)
    except Exception as read_err:
        return {"error": f"File read error: {read_err}"}

    payload = {
        "contents": [
            {
                "parts": [
                    {"text": LAYOUT_ANALYSIS_PROMPT},
                    {
                        "inline_data": {
                            "mime_type": "image/png",
                            "data": base64_img
                        }
                    },
                    {"text": f"Here is the shape metadata (JSON):\n\n{metadata_str}"}
                ]
            }
        ]
    }

    response = requests.post(GEMINI_URL, json=payload)
    if response.status_code != 200:
        return {"error": f"Gemini API Error: {response.text}"}

    try:
        output = response.json()["candidates"][0]["content"]["parts"][0]["text"]
        return {"analysis": output}
    except Exception as e:
        return {"error": f"Invalid response from Gemini: {e}"}













# from fastapi import FastAPI
# from fastapi.middleware.cors import CORSMiddleware
# import requests
# import base64
# import os
# import json
# import logging
# from typing import List

# from google import genai

# # Configure logging
# logging.basicConfig(level=logging.INFO)

# app = FastAPI()

# # CORS setup (optional for frontend integration)
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )


# LLM_API_KEY = "AIzaSyAv0sTw83EOKcJtoSyT9ug4cnzwGagkMJY"
# GEMINI_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={LLM_API_KEY}"

# ENHANCED_PROMPT = """You are an expert AI assistant analyzing a PowerPoint slide to identify layout and design issues, specifically focusing on overflow, and suggest precise, implementable fixes that can be understood by Office.js. Your primary goal is to resolve overflow while minimizing changes to the original relative positions and sizes of elements.

# **Input:**
# Slide Image: A visual representation of the PowerPoint slide.
# Shape Metadata (JSON): An array of JSON objects, each describing a shape with properties like id, name, type, top, left, width, height, zIndex, text, isGrouped, overlapsWith.


# 1. **Task (Focus on Overflow Resolution with Minimal Positional Changes):**
#     Analyze the slide image and the provided metadata to detect if any elements or groups of elements extend beyond the 960x540 pixel slide boundaries. Generate clear and concise instructions using Office.js terminology with specific property adjustments to resolve these overflow issues, prioritizing proportional resizing within the existing horizontal or vertical space of the overflowing row or column.

#     **Instructions for Handling Overflow:**

#     1.  **Identify Overflowing Elements:**
#         - Check each shape's `left + width` against 960 (horizontal) and `top + height` against 540 (vertical).

#     2.  **Handle Horizontal Overflow (Right Edge):**
#         - For each shape overflowing right (`left + width > 960`):
#             - **Determine Row:** Identify other shapes with similar `top` (within +/- 10 pixels). Let the row IDs be `{current_row_ids_str}`.
#             - **Analyze Row's Horizontal Span:** Find the leftmost (`min_left`) and rightmost (`max_right = left + width`) boundaries of the row.
#             - **Calculate Overflow:** `horizontal_overflow = max_right - 960`.
#             - **Calculate Available Reduction:** The maximum possible reduction in the row's width is `horizontal_overflow`.
#             - **Proportional Resizing (Prioritized):**
#                 - Calculate a `width_scale_factor` for the row: `(row_width - horizontal_overflow) / row_width`, where `row_width = max_right - min_left`. Ensure `width_scale_factor` is greater than a reasonable minimum (e.g., 0.7 to prevent extreme shrinkage).
#                 - For each shape in the row (id: {shape_id}, original width: {original_width}, original height: {original_height}, original left: {original_left}):
#                     - `new_width` = `original_width` * `width_scale_factor`.
#                     - `new_height` = `original_height` * `width_scale_factor`.
#                     - `delta_left` = `original_left` - `min_left`  # Maintain relative left position within the row
#                     - `new_left` = `min_left` + (`delta_left` * `width_scale_factor`)
#                     - Suggest: "Instruction: For shapes (ids: {current_row_ids_str}), set `width` to {new_width:.2f}, `height` to {new_height:.2f}, and `left` to {new_left:.2f} to fit within slide proportionally."
#             - **If Proportional Resizing is Insufficient or Undesirable:** (Consider this only if significant distortion would occur)
#                 - Suggest: "Instruction: For shapes (ids: {current_row_ids_str}), slightly reduce `width` by a uniform amount of {-uniform_width_reduction:.2f} and adjust `left` to maintain relative spacing." (This requires more sophisticated calculation of `-uniform_width_reduction` and `left` adjustments).

#     3.  **Handle Vertical Overflow (Bottom Edge):**
#         - For each shape overflowing bottom (`top + height > 540`):
#             - **Determine Column:** Identify other shapes with similar `left` (within +/- 10 pixels). Let the column IDs be `{current_column_ids_str}`.
#             - **Analyze Column's Vertical Span:** Find the topmost (`min_top`) and bottommost (`max_bottom = top + height`) boundaries of the column.
#             - **Calculate Overflow:** `vertical_overflow = max_bottom - 540`.
#             - **Calculate Available Reduction:** The maximum possible reduction in the column's height is `vertical_overflow`.
#             - **Proportional Resizing (Prioritized):** (Similar logic to horizontal overflow, applied vertically)
#                 - Suggest: "Instruction: For shapes (ids: {current_column_ids_str}), set `height` to {new_height:.2f}, `width` to {new_width:.2f}, and `top` to {new_top:.2f} to fit within slide proportionally."
#             - **If Proportional Resizing is Insufficient or Undesirable:**
#                 - Suggest: "Instruction: For shapes (ids: {current_column_ids_str}), slightly reduce `height` by a uniform amount of {-uniform_height_reduction:.2f} and adjust `top` to maintain relative spacing."


# 2. Detect Layout Inconsistencies:**
#    - **Misalignment (Rows/Columns):**
#      - Identify visual rows (similar `top` within +/- 10 pixels) and columns (similar `left` within +/- 10 pixels).
#      - For elements intended to be aligned within a row or column, if `top` or `left` differs by more than a small threshold (e.g., 5 pixels):
#        - **Prioritize Minor Adjustment:** Suggest adjusting the `top` or `left` of the misaligned shape to match a nearby, well-positioned element in the same row/column, ensuring the movement is within the 20-pixel limit.
#        - **Instruction Example:** "For shape '{misaligned_id}', set `top` to {target_top:.2f} to align with '{reference_id}'."
#    - **Overlapping (Non-Grouped):**
#      - Check `overlapsWith`. If overlapping shapes are not logically grouped:
#        - **Prioritize Minor Shift:** Suggest a minimal `left` or `top` adjustment (within 20 pixels) to one of the overlapping shapes to resolve the collision.
#        - **Instruction Example:** "For shape '{overlapping_id}', set `left` to {adjusted_left:.2f} to avoid overlap with '{other_id}'."
#    - **Inconsistent Sizes (Similar Elements in Rows/Columns):**
#      - Identify shapes of the same `type` or with similar names/roles within the same row or column.
#      - If `width` or `height` varies significantly (e.g., more than 10% difference):
#        - **Suggest Normalization with Minimal Change:** Recommend setting the `width` and/or `height` to a value closer to the median or average size of the group, ensuring the change doesn't cause significant layout disruption or overflow. Prioritize the smallest adjustments needed to improve consistency.
#        - **Instruction Example:** "For shapes (ids: {id1}, {id2}), adjust `width` to {normalized_width:.2f} to improve size consistency in the row."

# **3. Design Consistency Checks (Limited by Metadata):**
#    - **Text Alignment (Similar Text Elements in Rows/Columns):** If text shapes in the same row/column with similar content have inconsistent `textAlign`:
#      - **Suggest Normalization:** Recommend setting the `textAlign` to the most frequent value within the group.
#      - **Instruction Example:** "For text in shapes (ids: {id1}, {id2}), ensure `textAlign` is '{common_alignment}'."
#    - **Note:** Font size and detailed text formatting are harder to determine reliably from basic metadata and might require more advanced text parsing or visual analysis.

# 4.  **Prioritize Proportional Resizing:** The primary strategy is to resize elements proportionally within their existing row or column to eliminate overflow, minimizing the need to shift elements significantly.

# 5.  **Avoid Significant Positional Changes:** The `left` and `top` adjustments during proportional resizing should aim to maintain the relative positions of elements within the affected row or column. Avoid moving single elements or entire rows/columns drastically unless absolutely necessary as a last resort (and clearly indicate this in the instruction).

# 6.  **Output Format:**
#     - Provide clear instructions specifying the action (set `width`, set `height`, set `left`, set `top`) and the affected shape IDs with the calculated target values. For rows/columns, indicate that proportional resizing within the existing span is being applied.
#     - Clearly state the reason for each adjustment (e.g., "resolve right overflow", "align with shape 'X'", "normalize width", "improve horizontal spacing").
#     - When addressing rows or columns, list all affected shape IDs. 

# **Key Changes and Considerations in this Prompt:**

# * **Integration of All Issue Types:** This prompt now explicitly includes instructions for detecting and fixing overflow (using the V2 logic), misalignment, and inconsistent sizing, all while adhering to the constraint of minimal positional changes.
# * **Emphasis on Minimal Positional Changes:** The prompt explicitly states this as a primary goal.
# * **Prioritized Proportional Resizing:** Proportional resizing within the row/column's existing span is the preferred method.
# * **Row/Column Analysis:** The prompt now explicitly considers both horizontal (rows) and vertical (columns) overflow.
# * **Calculation of Available Reduction:** It guides the AI to calculate the maximum possible size reduction based on the overflow amount.
# * **Relative Positioning During Resize:** For proportional resizing, it instructs the AI to maintain the relative `left` (within a row) and `top` (within a column) positions of elements.
# * **Fallback with Uniform Reduction (Cautious):** It includes a fallback to uniform width/height reduction with spacing adjustments, but this is presented as a secondary option when proportional resizing might lead to unacceptable distortion. This approach needs careful implementation to avoid unintended layout changes.
# * **Clearer Instructions:** The instructions aim to be more specific about how `left` and `top` should be adjusted during resizing.
# """


# def analyze_slide_logic(image_path: str, metadata_path: str) -> dict:
#     if not os.path.exists(image_path):
#         return {"error": "Slide image not found."}
#     if not os.path.exists(metadata_path):
#         return {"error": "Metadata JSON not found."}

#     try:
#         with open(image_path, "rb") as img_file:
#             base64_img = base64.b64encode(img_file.read()).decode("utf-8")
#         with open(metadata_path, "r", encoding="utf-8") as json_file:
#             metadata_content = json.load(json_file)
#             metadata_str = json.dumps(metadata_content, indent=2)
#     except Exception as read_err:
#         return {"error": f"File read error: {read_err}"}

#     payload = {
#         "contents": [
#             {
#                 "parts": [
#                     {"text": ENHANCED_PROMPT},
#                     {
#                         "inline_data": {
#                             "mime_type": "image/png",
#                             "data": base64_img
#                         }
#                     },
#                     {
#                         "text": f"Here is the shape metadata (JSON):\n\n{metadata_str}"
#                     }
#                 ]
#             }
#         ]
#     }

#     response = requests.post(GEMINI_URL, json=payload)
#     if response.status_code != 200:
#         return {"error": f"Gemini API Error: {response.text}"}

#     try:
#         output = response.json()["candidates"][0]["content"]["parts"][0]["text"]
#         return {"analysis": output}
#     except Exception as e:
#         return {"error": f"Invalid response from Gemini: {e}"}

# @app.get("/analyze-slide")
# def analyze_slide():
#     # image_path = "slide_images/image.png"
#     image_path = "slide_images/images/presentation/slide_1.png"
#     metadata_path = "slide_images/metadata.json"
#     return analyze_slide_logic(image_path, metadata_path)











