{
  "NotesMasterPart": {
    "type": "class",
    "doc": "Notes master part.\n\nCorresponds to package file `ppt/notesMasters/notesMaster1.xml`.",
    "methods": {
      "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
      "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
      "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
      "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
      "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
      "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
      "related_part": "Return related |Part| subtype identified by `rId`.",
      "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
    }
  },
  "NotesSlidePart": {
    "type": "class",
    "doc": "Notes slide part.\n\nContains the slide notes content and the layout for the slide handout page.\nCorresponds to package file `ppt/notesSlides/notesSlide[1-9][0-9]*.xml`.",
    "methods": {
      "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
      "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
      "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
      "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
      "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
      "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
      "related_part": "Return related |Part| subtype identified by `rId`.",
      "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
    }
  },
  "action": {
    "type": "module",
    "doc": "Objects related to mouse click and hover actions on a shape or text.",
    "members": {
      "ActionSetting": {
        "type": "class",
        "doc": "Properties specifying how a shape or run reacts to mouse actions.",
        "methods": {}
      },
      "Hyperlink": {
        "type": "class",
        "doc": "Represents a hyperlink action on a shape or text run.",
        "methods": {}
      },
      "PP_ACTION": {
        "type": "class",
        "doc": "Specifies the type of a mouse action (click or hover action).\n\nAlias: ``PP_ACTION``\n\nExample::\n\n    from pptx.enum.action import PP_ACTION\n\n    assert shape.click_action.action == PP_ACTION.HYPERLINK\n\nMS API name: `PpActionType`\n\nhttps://msdn.microsoft.com/EN-US/library/office/ff744895.aspx",
        "methods": {}
      },
      "RT": {
        "type": "class",
        "doc": "No documentation",
        "methods": {}
      },
      "Subshape": {
        "type": "class",
        "doc": "Provides access to the containing part for drawing elements that occur below a shape.\n\nAccess to the part is required for example to add or drop a relationship. Provides\n`self._parent` attribute to subclasses.",
        "methods": {}
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "api": {
    "type": "module",
    "doc": "Directly exposed API classes, Presentation for now.\n\nProvides some syntactic sugar for interacting with the pptx.presentation.Package graph and also\nprovides some insulation so not so many classes in the other modules need to be named as internal\n(leading underscore).",
    "members": {
      "CT": {
        "type": "class",
        "doc": "Content type URIs (like MIME-types) that specify a part's format.",
        "methods": {}
      },
      "IO": {
        "type": "class",
        "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
        "methods": {
          "close": "No documentation",
          "fileno": "No documentation",
          "flush": "No documentation",
          "isatty": "No documentation",
          "read": "No documentation",
          "readable": "No documentation",
          "readline": "No documentation",
          "readlines": "No documentation",
          "seek": "No documentation",
          "seekable": "No documentation",
          "tell": "No documentation",
          "truncate": "No documentation",
          "writable": "No documentation",
          "write": "No documentation",
          "writelines": "No documentation"
        }
      },
      "Package": {
        "type": "class",
        "doc": "An overall .pptx package.",
        "methods": {
          "drop_rel": "Remove relationship identified by `rId`.",
          "get_or_add_image_part": "Return an |ImagePart| object containing the image in *image_file*. If\nthe image part already exists in this package, it is reused,\notherwise a new one is created.",
          "get_or_add_media_part": "Return a |MediaPart| object containing the media in *media*.\n\nIf a media part for this media bytestream (\"file\") is already present\nin this package, it is reused, otherwise a new one is created.",
          "iter_parts": "Generate exactly one reference to each part in the package.",
          "iter_rels": "Generate exactly one reference to each relationship in package.\n\nPerforms a depth-first traversal of the rels graph.",
          "next_image_partname": "Return a |PackURI| instance representing the next available image partname.\n\nPartname uses the next available sequence number. *ext* is used as the extention on the\nreturned partname.",
          "next_media_partname": "Return |PackURI| instance for next available media partname.\n\nPartname is first available, starting at sequence number 1. Empty\nsequence numbers are reused. *ext* is used as the extension on the\nreturned partname.",
          "next_partname": "Return |PackURI| next available partname matching `tmpl`.\n\n`tmpl` is a printf (%)-style template string containing a single replacement item, a '%d'\nto be used to insert the integer portion of the partname. Example:\n'/ppt/slides/slide%d.xml'",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "save": "Save this package to `pkg_file`.\n\n`file` can be either a path to a file (a string) or a file-like object.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      }
    }
  },
  "chart": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "axis": {
        "type": "module",
        "doc": "Axis-related chart objects.",
        "members": {
          "AxisTitle": {
            "type": "class",
            "doc": "Provides properties for manipulating axis title.",
            "methods": {}
          },
          "CategoryAxis": {
            "type": "class",
            "doc": "A category axis of a chart.",
            "methods": {}
          },
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "DateAxis": {
            "type": "class",
            "doc": "A category axis with dates as its category labels.\n\nThis axis-type has some special display behaviors such as making length of equal\nperiods equal and normalizing month start dates despite unequal month lengths.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "Font": {
            "type": "class",
            "doc": "Character properties object, providing font size, font name, bold, italic, etc.\n\nCorresponds to `a:rPr` child element of a run. Also appears as `a:defRPr` and\n`a:endParaRPr` in paragraph and `a:defRPr` in list style elements.",
            "methods": {}
          },
          "MajorGridlines": {
            "type": "class",
            "doc": "Provides access to the properties of the major gridlines appearing on an axis.",
            "methods": {}
          },
          "ST_Orientation": {
            "type": "class",
            "doc": "Valid values for `val` attribute on c:orientation (CT_Orientation).",
            "methods": {}
          },
          "TextFrame": {
            "type": "class",
            "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
            "methods": {
              "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
              "clear": "Remove all paragraphs except one empty one.",
              "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
            }
          },
          "TickLabels": {
            "type": "class",
            "doc": "A service class providing access to formatting of axis tick mark labels.",
            "methods": {}
          },
          "ValueAxis": {
            "type": "class",
            "doc": "An axis having continuous (as opposed to discrete) values.\n\nThe vertical axis is generally a value axis, however both axes of an XY-type chart\nare value axes.",
            "methods": {}
          },
          "XL_AXIS_CROSSES": {
            "type": "class",
            "doc": "Specifies the point on an axis where the other axis crosses.\n\nExample::\n\n    from pptx.enum.chart import XL_AXIS_CROSSES\n\n    value_axis.crosses = XL_AXIS_CROSSES.MAXIMUM\n\nMS API Name: `XlAxisCrosses`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff745402.aspx",
            "methods": {}
          },
          "XL_CATEGORY_TYPE": {
            "type": "class",
            "doc": "Specifies the type of the category axis.\n\nExample::\n\n    from pptx.enum.chart import XL_CATEGORY_TYPE\n\n    date_axis = chart.category_axis\n    assert date_axis.category_type == XL_CATEGORY_TYPE.TIME_SCALE\n\nMS API Name: `XlCategoryType`\n\nhttps://msdn.microsoft.com/EN-US/library/office/ff746136.aspx",
            "methods": {}
          },
          "XL_TICK_LABEL_POSITION": {
            "type": "class",
            "doc": "Specifies the position of tick-mark labels on a chart axis.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_LABEL_POSITION\n\n    category_axis = chart.category_axis\n    category_axis.tick_label_position = XL_TICK_LABEL_POSITION.LOW\n\nMS API Name: `XlTickLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff822561.aspx",
            "methods": {}
          },
          "XL_TICK_MARK": {
            "type": "class",
            "doc": "Specifies a type of axis tick for a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_MARK\n\n    chart.value_axis.minor_tick_mark = XL_TICK_MARK.INSIDE\n\nMS API Name: `XlTickMark`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff193878.aspx",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "category": {
        "type": "module",
        "doc": "Category-related objects.\n\nThe |category.Categories| object is returned by ``Plot.categories`` and contains zero or\nmore |category.Category| objects, each representing one of the category labels\nassociated with the plot. Categories can be hierarchical, so there are members allowing\ndiscovery of the depth of that hierarchy and providing means to navigate it.",
        "members": {
          "Categories": {
            "type": "class",
            "doc": "A sequence of |category.Category| objects, each representing a category\nlabel on the chart. Provides properties for dealing with hierarchical\ncategories.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "Category": {
            "type": "class",
            "doc": "An extension of `str` that provides the category label as its string\nvalue, and additional attributes representing other aspects of the\ncategory.",
            "methods": {}
          },
          "CategoryLevel": {
            "type": "class",
            "doc": "A sequence of |category.Category| objects representing a single level in\na hierarchical category collection. This object is only used when the\ncategories are hierarchical, meaning they have more than one level and\nhigher level categories group those at lower levels.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "Sequence": {
            "type": "class",
            "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          }
        }
      },
      "chart": {
        "type": "module",
        "doc": "Chart-related objects such as Chart and ChartTitle.",
        "members": {
          "CategoryAxis": {
            "type": "class",
            "doc": "A category axis of a chart.",
            "methods": {}
          },
          "Chart": {
            "type": "class",
            "doc": "A chart object.",
            "methods": {
              "replace_data": "Use the categories and series values in the |ChartData| object\n*chart_data* to replace those in the XML and Excel worksheet for this\nchart."
            }
          },
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "ChartTitle": {
            "type": "class",
            "doc": "Provides properties for manipulating a chart title.",
            "methods": {}
          },
          "DateAxis": {
            "type": "class",
            "doc": "A category axis with dates as its category labels.\n\nThis axis-type has some special display behaviors such as making length of equal\nperiods equal and normalizing month start dates despite unequal month lengths.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "Font": {
            "type": "class",
            "doc": "Character properties object, providing font size, font name, bold, italic, etc.\n\nCorresponds to `a:rPr` child element of a run. Also appears as `a:defRPr` and\n`a:endParaRPr` in paragraph and `a:defRPr` in list style elements.",
            "methods": {}
          },
          "Legend": {
            "type": "class",
            "doc": "Represents the legend in a chart. A chart can have at most one legend.",
            "methods": {}
          },
          "PartElementProxy": {
            "type": "class",
            "doc": "Provides common members for proxy-objects that wrap a part's root element, e.g. `p:sld`.",
            "methods": {}
          },
          "PlotTypeInspector": {
            "type": "class",
            "doc": "\"One-shot\" service object that knows how to identify the type of a plot\nas a member of the XL_CHART_TYPE enumeration.",
            "methods": {}
          },
          "Sequence": {
            "type": "class",
            "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "SeriesCollection": {
            "type": "class",
            "doc": "A sequence of |Series| objects.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "TextFrame": {
            "type": "class",
            "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
            "methods": {
              "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
              "clear": "Remove all paragraphs except one empty one.",
              "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
            }
          },
          "ValueAxis": {
            "type": "class",
            "doc": "An axis having continuous (as opposed to discrete) values.\n\nThe vertical axis is generally a value axis, however both axes of an XY-type chart\nare value axes.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "datalabel": {
        "type": "module",
        "doc": "Data label-related objects.",
        "members": {
          "DataLabel": {
            "type": "class",
            "doc": "The data label associated with an individual data point.",
            "methods": {}
          },
          "DataLabels": {
            "type": "class",
            "doc": "Provides access to properties of data labels for a plot or a series.\n\nThis is not a collection and does not provide access to individual data\nlabels. Access to individual labels is via the |Point| object. The\nproperties this object provides control formatting of *all* the data\nlabels in its scope.",
            "methods": {}
          },
          "Font": {
            "type": "class",
            "doc": "Character properties object, providing font size, font name, bold, italic, etc.\n\nCorresponds to `a:rPr` child element of a run. Also appears as `a:defRPr` and\n`a:endParaRPr` in paragraph and `a:defRPr` in list style elements.",
            "methods": {}
          },
          "TextFrame": {
            "type": "class",
            "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
            "methods": {
              "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
              "clear": "Remove all paragraphs except one empty one.",
              "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "legend": {
        "type": "module",
        "doc": "Legend of a chart.",
        "members": {
          "Font": {
            "type": "class",
            "doc": "Character properties object, providing font size, font name, bold, italic, etc.\n\nCorresponds to `a:rPr` child element of a run. Also appears as `a:defRPr` and\n`a:endParaRPr` in paragraph and `a:defRPr` in list style elements.",
            "methods": {}
          },
          "Legend": {
            "type": "class",
            "doc": "Represents the legend in a chart. A chart can have at most one legend.",
            "methods": {}
          },
          "XL_LEGEND_POSITION": {
            "type": "class",
            "doc": "Specifies the position of the legend on a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_LEGEND_POSITION\n\n    chart.has_legend = True\n    chart.legend.position = XL_LEGEND_POSITION.BOTTOM\n\nMS API Name: `XlLegendPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745840.aspx",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "marker": {
        "type": "module",
        "doc": "Marker-related objects.\n\nOnly the line-type charts Line, XY, and Radar have markers.",
        "members": {
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "Marker": {
            "type": "class",
            "doc": "Represents a data point marker, such as a diamond or circle, on\na line-type chart.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "plot": {
        "type": "module",
        "doc": "Plot-related objects.\n\nA plot is known as a chart group in the MS API. A chart can have more than one plot overlayed on\neach other, such as a line plot layered over a bar plot.",
        "members": {
          "Area3DPlot": {
            "type": "class",
            "doc": "A 3-dimensional area plot.",
            "methods": {}
          },
          "AreaPlot": {
            "type": "class",
            "doc": "An area plot.",
            "methods": {}
          },
          "BarPlot": {
            "type": "class",
            "doc": "A bar chart-style plot.",
            "methods": {}
          },
          "BubblePlot": {
            "type": "class",
            "doc": "A bubble chart plot.",
            "methods": {}
          },
          "Categories": {
            "type": "class",
            "doc": "A sequence of |category.Category| objects, each representing a category\nlabel on the chart. Provides properties for dealing with hierarchical\ncategories.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "DataLabels": {
            "type": "class",
            "doc": "Provides access to properties of data labels for a plot or a series.\n\nThis is not a collection and does not provide access to individual data\nlabels. Access to individual labels is via the |Point| object. The\nproperties this object provides control formatting of *all* the data\nlabels in its scope.",
            "methods": {}
          },
          "DoughnutPlot": {
            "type": "class",
            "doc": "An doughnut plot.",
            "methods": {}
          },
          "LinePlot": {
            "type": "class",
            "doc": "A line chart-style plot.",
            "methods": {}
          },
          "PiePlot": {
            "type": "class",
            "doc": "A pie chart-style plot.",
            "methods": {}
          },
          "PlotTypeInspector": {
            "type": "class",
            "doc": "\"One-shot\" service object that knows how to identify the type of a plot\nas a member of the XL_CHART_TYPE enumeration.",
            "methods": {}
          },
          "RadarPlot": {
            "type": "class",
            "doc": "A radar-style plot.",
            "methods": {}
          },
          "ST_BarDir": {
            "type": "class",
            "doc": "Valid values for <c:barDir val=\"?\"> attribute",
            "methods": {}
          },
          "ST_Grouping": {
            "type": "class",
            "doc": "Valid values for <c:grouping val=\"\"> attribute. Overloaded for use as\nST_BarGrouping using same tag name.",
            "methods": {}
          },
          "SeriesCollection": {
            "type": "class",
            "doc": "A sequence of |Series| objects.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "XL": {
            "type": "class",
            "doc": "Specifies the type of a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_CHART_TYPE\n\n    assert chart.chart_type == XL_CHART_TYPE.BAR_STACKED\n\nMS API Name: `XlChartType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff838409.aspx",
            "methods": {}
          },
          "XyPlot": {
            "type": "class",
            "doc": "An XY (scatter) plot.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "point": {
        "type": "module",
        "doc": "Data point-related objects.",
        "members": {
          "BubblePoints": {
            "type": "class",
            "doc": "Sequence providing access to the individual data points in\na |BubbleSeries| object.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "CategoryPoints": {
            "type": "class",
            "doc": "Sequence providing access to individual |Point| objects, each\nrepresenting the visual properties of a data point in the specified\ncategory series.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "DataLabel": {
            "type": "class",
            "doc": "The data label associated with an individual data point.",
            "methods": {}
          },
          "Marker": {
            "type": "class",
            "doc": "Represents a data point marker, such as a diamond or circle, on\na line-type chart.",
            "methods": {}
          },
          "Point": {
            "type": "class",
            "doc": "Provides access to the properties of an individual data point in\na series, such as the visual properties of its marker and the text and\nfont of its data label.",
            "methods": {}
          },
          "Sequence": {
            "type": "class",
            "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "XyPoints": {
            "type": "class",
            "doc": "Sequence providing access to the individual data points in an |XySeries|\nobject.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "series": {
        "type": "module",
        "doc": "Series-related objects.",
        "members": {
          "AreaSeries": {
            "type": "class",
            "doc": "A data point series belonging to an area plot.",
            "methods": {}
          },
          "BarSeries": {
            "type": "class",
            "doc": "A data point series belonging to a bar plot.",
            "methods": {}
          },
          "BubblePoints": {
            "type": "class",
            "doc": "Sequence providing access to the individual data points in\na |BubbleSeries| object.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "BubbleSeries": {
            "type": "class",
            "doc": "A data point series belonging to a bubble plot.",
            "methods": {
              "iter_values": "Generate each float Y value in this series, in the order they appear\non the chart. A value of `None` represents a missing Y value\n(corresponding to a blank Excel cell)."
            }
          },
          "CategoryPoints": {
            "type": "class",
            "doc": "Sequence providing access to individual |Point| objects, each\nrepresenting the visual properties of a data point in the specified\ncategory series.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "DataLabels": {
            "type": "class",
            "doc": "Provides access to properties of data labels for a plot or a series.\n\nThis is not a collection and does not provide access to individual data\nlabels. Access to individual labels is via the |Point| object. The\nproperties this object provides control formatting of *all* the data\nlabels in its scope.",
            "methods": {}
          },
          "LineSeries": {
            "type": "class",
            "doc": "A data point series belonging to a line plot.",
            "methods": {}
          },
          "Marker": {
            "type": "class",
            "doc": "Represents a data point marker, such as a diamond or circle, on\na line-type chart.",
            "methods": {}
          },
          "PieSeries": {
            "type": "class",
            "doc": "A data point series belonging to a pie plot.",
            "methods": {}
          },
          "RadarSeries": {
            "type": "class",
            "doc": "A data point series belonging to a radar plot.",
            "methods": {}
          },
          "Sequence": {
            "type": "class",
            "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "SeriesCollection": {
            "type": "class",
            "doc": "A sequence of |Series| objects.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "XyPoints": {
            "type": "class",
            "doc": "Sequence providing access to the individual data points in an |XySeries|\nobject.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "XySeries": {
            "type": "class",
            "doc": "A data point series belonging to an XY (scatter) plot.",
            "methods": {
              "iter_values": "Generate each float Y value in this series, in the order they appear\non the chart. A value of `None` represents a missing Y value\n(corresponding to a blank Excel cell)."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "xmlwriter": {
        "type": "module",
        "doc": "Composers for default chart XML for various chart types.",
        "members": {
          "XL_CHART_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_CHART_TYPE\n\n    assert chart.chart_type == XL_CHART_TYPE.BAR_STACKED\n\nMS API Name: `XlChartType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff838409.aspx",
            "methods": {}
          }
        }
      }
    }
  },
  "dml": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "chtfmt": {
        "type": "module",
        "doc": "|ChartFormat| and related objects.\n\n|ChartFormat| acts as proxy for the `spPr` element, which provides visual shape properties such as\nline and fill for chart elements.",
        "members": {
          "ChartFormat": {
            "type": "class",
            "doc": "The |ChartFormat| object provides access to visual shape properties for\nchart elements like |Axis|, |Series|, and |MajorGridlines|. It has two\nproperties, :attr:`fill` and :attr:`line`, which return a |FillFormat|\nand |LineFormat| object respectively. The |ChartFormat| object is\nprovided by the :attr:`format` property on the target axis, series, etc.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "FillFormat": {
            "type": "class",
            "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
            "methods": {
              "background": "Sets the fill type to noFill, i.e. transparent.",
              "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
              "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
              "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
            }
          },
          "LineFormat": {
            "type": "class",
            "doc": "Provides access to line properties such as color, style, and width.\n\nA LineFormat object is typically accessed via the ``.line`` property of\na shape such as |Shape| or |Picture|.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "color": {
        "type": "module",
        "doc": "DrawingML objects related to color, ColorFormat being the most prominent.",
        "members": {
          "CT_HslColor": {
            "type": "class",
            "doc": "Custom element class for <a:hslClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_PresetColor": {
            "type": "class",
            "doc": "Custom element class for <a:prstClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SRgbColor": {
            "type": "class",
            "doc": "Custom element class for <a:srgbClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_ScRgbColor": {
            "type": "class",
            "doc": "Custom element class for <a:scrgbClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SchemeColor": {
            "type": "class",
            "doc": "Custom element class for <a:schemeClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SystemColor": {
            "type": "class",
            "doc": "Custom element class for <a:sysClr> element.",
            "methods": {
              "add_lumMod": "Return a newly added <a:lumMod> child element.",
              "add_lumOff": "Return a newly added <a:lumOff> child element.",
              "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
              "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ColorFormat": {
            "type": "class",
            "doc": "Provides access to color settings such as RGB color, theme color, and\nluminance adjustments.",
            "methods": {}
          },
          "MSO_COLOR_TYPE": {
            "type": "class",
            "doc": "Specifies the color specification scheme\n\nExample::\n\n    from pptx.enum.dml import MSO_COLOR_TYPE\n\n    assert shape.fill.fore_color.type == MSO_COLOR_TYPE.SCHEME\n\nMS API Name: \"MsoColorType\"\n\nhttp://msdn.microsoft.com/en-us/library/office/ff864912(v=office.15).aspx",
            "methods": {}
          },
          "MSO_THEME_COLOR": {
            "type": "class",
            "doc": "An Office theme color, one of those shown in the color gallery on the formatting ribbon.\n\nAlias: ``MSO_THEME_COLOR``\n\nExample::\n\n    from pptx.enum.dml import MSO_THEME_COLOR\n\n    shape.fill.solid()\n    shape.fill.fore_color.theme_color = MSO_THEME_COLOR.ACCENT_1\n\nMS API Name: `MsoThemeColorIndex`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860782(v=office.15).aspx",
            "methods": {}
          },
          "RGBColor": {
            "type": "class",
            "doc": "Immutable value object defining a particular RGB color.",
            "methods": {}
          }
        }
      },
      "effect": {
        "type": "module",
        "doc": "Visual effects on a shape such as shadow, glow, and reflection.",
        "members": {
          "ShadowFormat": {
            "type": "class",
            "doc": "Provides access to shadow effect on a shape.",
            "methods": {}
          }
        }
      },
      "fill": {
        "type": "module",
        "doc": "DrawingML objects related to fill.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_BlipFillProperties": {
            "type": "class",
            "doc": "Custom element class for <a:blipFill> element.",
            "methods": {
              "crop": "Set `a:srcRect` child to crop according to *cropping* values.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_blip": "Return the ``<a:blip>`` child element, newly added if not present.",
              "get_or_add_srcRect": "Return the ``<a:srcRect>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_GradientFillProperties": {
            "type": "class",
            "doc": "`a:gradFill` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
              "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
              "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_GroupFillProperties": {
            "type": "class",
            "doc": "`a:grpFill` custom element class",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_NoFillProperties": {
            "type": "class",
            "doc": "`a:noFill` custom element class",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_PatternFillProperties": {
            "type": "class",
            "doc": "`a:pattFill` custom element class",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_bgClr": "Return the ``<a:bgClr>`` child element, newly added if not present.",
              "get_or_add_fgClr": "Return the ``<a:fgClr>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SolidColorFillProperties": {
            "type": "class",
            "doc": "`a:solidFill` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
              "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
              "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
              "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
              "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
              "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ColorFormat": {
            "type": "class",
            "doc": "Provides access to color settings such as RGB color, theme color, and\nluminance adjustments.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "FillFormat": {
            "type": "class",
            "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
            "methods": {
              "background": "Sets the fill type to noFill, i.e. transparent.",
              "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
              "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
              "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
            }
          },
          "MSO_FILL": {
            "type": "class",
            "doc": "Specifies the type of bitmap used for the fill of a shape.\n\nAlias: ``MSO_FILL``\n\nExample::\n\n    from pptx.enum.dml import MSO_FILL\n\n    assert shape.fill.type == MSO_FILL.SOLID\n\nMS API Name: `MsoFillType`\n\nhttp://msdn.microsoft.com/EN-US/library/office/ff861408.aspx",
            "methods": {}
          },
          "Sequence": {
            "type": "class",
            "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
            "methods": {
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "line": {
        "type": "module",
        "doc": "DrawingML objects related to line formatting.",
        "members": {
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "FillFormat": {
            "type": "class",
            "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
            "methods": {
              "background": "Sets the fill type to noFill, i.e. transparent.",
              "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
              "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
              "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
            }
          },
          "LineFormat": {
            "type": "class",
            "doc": "Provides access to line properties such as color, style, and width.\n\nA LineFormat object is typically accessed via the ``.line`` property of\na shape such as |Shape| or |Picture|.",
            "methods": {}
          },
          "MSO_FILL": {
            "type": "class",
            "doc": "Specifies the type of bitmap used for the fill of a shape.\n\nAlias: ``MSO_FILL``\n\nExample::\n\n    from pptx.enum.dml import MSO_FILL\n\n    assert shape.fill.type == MSO_FILL.SOLID\n\nMS API Name: `MsoFillType`\n\nhttp://msdn.microsoft.com/EN-US/library/office/ff861408.aspx",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      }
    }
  },
  "enum": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "action": {
        "type": "module",
        "doc": "Enumerations that describe click-action settings.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "PP_ACTION": {
            "type": "class",
            "doc": "Specifies the type of a mouse action (click or hover action).\n\nAlias: ``PP_ACTION``\n\nExample::\n\n    from pptx.enum.action import PP_ACTION\n\n    assert shape.click_action.action == PP_ACTION.HYPERLINK\n\nMS API name: `PpActionType`\n\nhttps://msdn.microsoft.com/EN-US/library/office/ff744895.aspx",
            "methods": {}
          },
          "PP_ACTION_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a mouse action (click or hover action).\n\nAlias: ``PP_ACTION``\n\nExample::\n\n    from pptx.enum.action import PP_ACTION\n\n    assert shape.click_action.action == PP_ACTION.HYPERLINK\n\nMS API name: `PpActionType`\n\nhttps://msdn.microsoft.com/EN-US/library/office/ff744895.aspx",
            "methods": {}
          }
        }
      },
      "base": {
        "type": "module",
        "doc": "Base classes and other objects used by enumerations.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "DocsPageFormatter": {
            "type": "class",
            "doc": "Formats a reStructuredText documention page (string) for an enumeration.",
            "methods": {}
          },
          "TypeVar": {
            "type": "class",
            "doc": "Type variable.\n\nUsage::\n\n  T = TypeVar('T')  # Can be anything\n  A = TypeVar('A', str, bytes)  # Must be str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function definitions.  See class Generic for more\ninformation on generic types.  Generic functions work as follows:\n\n  def repeat(x: T, n: int) -> List[T]:\n      '''Return a list containing n references to x.'''\n      return [x]*n\n\n  def longest(x: A, y: A) -> A:\n      '''Return the longest of two strings.'''\n      return x if len(x) >= len(y) else y\n\nThe latter example's signature is essentially the overloading\nof (str, str) -> str and (bytes, bytes) -> bytes.  Also note\nthat if the arguments are instances of some subclass of str,\nthe return type is still plain str.\n\nAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\nType variables defined with covariant=True or contravariant=True\ncan be used to declare covariant or contravariant generic types.\nSee PEP 484 for more details. By default generic types are invariant\nin all type variables.\n\nType variables can be introspected. e.g.:\n\n  T.__name__ == 'T'\n  T.__constraints__ == ()\n  T.__covariant__ == False\n  T.__contravariant__ = False\n  A.__constraints__ == (str, bytes)\n\nNote that only type variables defined in global scope can be pickled.",
            "methods": {}
          }
        }
      },
      "chart": {
        "type": "module",
        "doc": "Enumerations used by charts and related objects.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "XL_AXIS_CROSSES": {
            "type": "class",
            "doc": "Specifies the point on an axis where the other axis crosses.\n\nExample::\n\n    from pptx.enum.chart import XL_AXIS_CROSSES\n\n    value_axis.crosses = XL_AXIS_CROSSES.MAXIMUM\n\nMS API Name: `XlAxisCrosses`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff745402.aspx",
            "methods": {}
          },
          "XL_CATEGORY_TYPE": {
            "type": "class",
            "doc": "Specifies the type of the category axis.\n\nExample::\n\n    from pptx.enum.chart import XL_CATEGORY_TYPE\n\n    date_axis = chart.category_axis\n    assert date_axis.category_type == XL_CATEGORY_TYPE.TIME_SCALE\n\nMS API Name: `XlCategoryType`\n\nhttps://msdn.microsoft.com/EN-US/library/office/ff746136.aspx",
            "methods": {}
          },
          "XL_CHART_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_CHART_TYPE\n\n    assert chart.chart_type == XL_CHART_TYPE.BAR_STACKED\n\nMS API Name: `XlChartType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff838409.aspx",
            "methods": {}
          },
          "XL_DATA_LABEL_POSITION": {
            "type": "class",
            "doc": "Specifies where the data label is positioned.\n\nExample::\n\n    from pptx.enum.chart import XL_LABEL_POSITION\n\n    data_labels = chart.plots[0].data_labels\n    data_labels.position = XL_LABEL_POSITION.OUTSIDE_END\n\nMS API Name: `XlDataLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745082.aspx",
            "methods": {}
          },
          "XL_LABEL_POSITION": {
            "type": "class",
            "doc": "Specifies where the data label is positioned.\n\nExample::\n\n    from pptx.enum.chart import XL_LABEL_POSITION\n\n    data_labels = chart.plots[0].data_labels\n    data_labels.position = XL_LABEL_POSITION.OUTSIDE_END\n\nMS API Name: `XlDataLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745082.aspx",
            "methods": {}
          },
          "XL_LEGEND_POSITION": {
            "type": "class",
            "doc": "Specifies the position of the legend on a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_LEGEND_POSITION\n\n    chart.has_legend = True\n    chart.legend.position = XL_LEGEND_POSITION.BOTTOM\n\nMS API Name: `XlLegendPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745840.aspx",
            "methods": {}
          },
          "XL_MARKER_STYLE": {
            "type": "class",
            "doc": "Specifies the marker style for a point or series in a line, scatter, or radar chart.\n\nExample::\n\n    from pptx.enum.chart import XL_MARKER_STYLE\n\n    series.marker.style = XL_MARKER_STYLE.CIRCLE\n\nMS API Name: `XlMarkerStyle`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff197219.aspx",
            "methods": {}
          },
          "XL_TICK_LABEL_POSITION": {
            "type": "class",
            "doc": "Specifies the position of tick-mark labels on a chart axis.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_LABEL_POSITION\n\n    category_axis = chart.category_axis\n    category_axis.tick_label_position = XL_TICK_LABEL_POSITION.LOW\n\nMS API Name: `XlTickLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff822561.aspx",
            "methods": {}
          },
          "XL_TICK_MARK": {
            "type": "class",
            "doc": "Specifies a type of axis tick for a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_MARK\n\n    chart.value_axis.minor_tick_mark = XL_TICK_MARK.INSIDE\n\nMS API Name: `XlTickMark`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff193878.aspx",
            "methods": {}
          }
        }
      },
      "dml": {
        "type": "module",
        "doc": "Enumerations used by DrawingML objects.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "MSO_COLOR_TYPE": {
            "type": "class",
            "doc": "Specifies the color specification scheme\n\nExample::\n\n    from pptx.enum.dml import MSO_COLOR_TYPE\n\n    assert shape.fill.fore_color.type == MSO_COLOR_TYPE.SCHEME\n\nMS API Name: \"MsoColorType\"\n\nhttp://msdn.microsoft.com/en-us/library/office/ff864912(v=office.15).aspx",
            "methods": {}
          },
          "MSO_FILL": {
            "type": "class",
            "doc": "Specifies the type of bitmap used for the fill of a shape.\n\nAlias: ``MSO_FILL``\n\nExample::\n\n    from pptx.enum.dml import MSO_FILL\n\n    assert shape.fill.type == MSO_FILL.SOLID\n\nMS API Name: `MsoFillType`\n\nhttp://msdn.microsoft.com/EN-US/library/office/ff861408.aspx",
            "methods": {}
          },
          "MSO_FILL_TYPE": {
            "type": "class",
            "doc": "Specifies the type of bitmap used for the fill of a shape.\n\nAlias: ``MSO_FILL``\n\nExample::\n\n    from pptx.enum.dml import MSO_FILL\n\n    assert shape.fill.type == MSO_FILL.SOLID\n\nMS API Name: `MsoFillType`\n\nhttp://msdn.microsoft.com/EN-US/library/office/ff861408.aspx",
            "methods": {}
          },
          "MSO_LINE": {
            "type": "class",
            "doc": "Specifies the dash style for a line.\n\nAlias: ``MSO_LINE``\n\nExample::\n\n    from pptx.enum.dml import MSO_LINE\n\n    shape.line.dash_style = MSO_LINE.DASH_DOT_DOT\n\nMS API name: `MsoLineDashStyle`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoLineDashStyle",
            "methods": {}
          },
          "MSO_LINE_DASH_STYLE": {
            "type": "class",
            "doc": "Specifies the dash style for a line.\n\nAlias: ``MSO_LINE``\n\nExample::\n\n    from pptx.enum.dml import MSO_LINE\n\n    shape.line.dash_style = MSO_LINE.DASH_DOT_DOT\n\nMS API name: `MsoLineDashStyle`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoLineDashStyle",
            "methods": {}
          },
          "MSO_PATTERN": {
            "type": "class",
            "doc": "Specifies the fill pattern used in a shape.\n\nAlias: ``MSO_PATTERN``\n\nExample::\n\n    from pptx.enum.dml import MSO_PATTERN\n\n    fill = shape.fill\n    fill.patterned()\n    fill.pattern = MSO_PATTERN.WAVE\n\nMS API Name: `MsoPatternType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoPatternType",
            "methods": {}
          },
          "MSO_PATTERN_TYPE": {
            "type": "class",
            "doc": "Specifies the fill pattern used in a shape.\n\nAlias: ``MSO_PATTERN``\n\nExample::\n\n    from pptx.enum.dml import MSO_PATTERN\n\n    fill = shape.fill\n    fill.patterned()\n    fill.pattern = MSO_PATTERN.WAVE\n\nMS API Name: `MsoPatternType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoPatternType",
            "methods": {}
          },
          "MSO_THEME_COLOR": {
            "type": "class",
            "doc": "An Office theme color, one of those shown in the color gallery on the formatting ribbon.\n\nAlias: ``MSO_THEME_COLOR``\n\nExample::\n\n    from pptx.enum.dml import MSO_THEME_COLOR\n\n    shape.fill.solid()\n    shape.fill.fore_color.theme_color = MSO_THEME_COLOR.ACCENT_1\n\nMS API Name: `MsoThemeColorIndex`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860782(v=office.15).aspx",
            "methods": {}
          },
          "MSO_THEME_COLOR_INDEX": {
            "type": "class",
            "doc": "An Office theme color, one of those shown in the color gallery on the formatting ribbon.\n\nAlias: ``MSO_THEME_COLOR``\n\nExample::\n\n    from pptx.enum.dml import MSO_THEME_COLOR\n\n    shape.fill.solid()\n    shape.fill.fore_color.theme_color = MSO_THEME_COLOR.ACCENT_1\n\nMS API Name: `MsoThemeColorIndex`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860782(v=office.15).aspx",
            "methods": {}
          }
        }
      },
      "lang": {
        "type": "module",
        "doc": "Enumerations used for specifying language.",
        "members": {
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "MSO_LANGUAGE_ID": {
            "type": "class",
            "doc": "Specifies the language identifier.\n\nExample::\n\n    from pptx.enum.lang import MSO_LANGUAGE_ID\n\n    font.language_id = MSO_LANGUAGE_ID.POLISH\n\nMS API Name: `MsoLanguageId`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff862134.aspx",
            "methods": {}
          }
        }
      },
      "shapes": {
        "type": "module",
        "doc": "Enumerations used by shapes and related objects.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "MSO": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "MSO_AUTO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
            "methods": {}
          },
          "MSO_CONNECTOR": {
            "type": "class",
            "doc": "Specifies a type of connector.\n\nAlias: ``MSO_CONNECTOR``\n\nExample::\n\n    from pptx.enum.shapes import MSO_CONNECTOR\n    from pptx.util import Cm\n\n    shapes = prs.slides[0].shapes\n    connector = shapes.add_connector(\n        MSO_CONNECTOR.STRAIGHT, Cm(2), Cm(2), Cm(10), Cm(10)\n    )\n    assert connector.left.cm == 2\n\nMS API Name: `MsoConnectorType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860918.aspx",
            "methods": {}
          },
          "MSO_CONNECTOR_TYPE": {
            "type": "class",
            "doc": "Specifies a type of connector.\n\nAlias: ``MSO_CONNECTOR``\n\nExample::\n\n    from pptx.enum.shapes import MSO_CONNECTOR\n    from pptx.util import Cm\n\n    shapes = prs.slides[0].shapes\n    connector = shapes.add_connector(\n        MSO_CONNECTOR.STRAIGHT, Cm(2), Cm(2), Cm(10), Cm(10)\n    )\n    assert connector.left.cm == 2\n\nMS API Name: `MsoConnectorType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860918.aspx",
            "methods": {}
          },
          "MSO_SHAPE": {
            "type": "class",
            "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "PP_MEDIA_TYPE": {
            "type": "class",
            "doc": "Indicates the OLE media type.\n\nExample::\n\n    from pptx.enum.shapes import PP_MEDIA_TYPE\n\n    movie = slide.shapes[0]\n    assert movie.media_type == PP_MEDIA_TYPE.MOVIE\n\nMS API Name: `PpMediaType`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff746008.aspx",
            "methods": {}
          },
          "PP_PLACEHOLDER": {
            "type": "class",
            "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
            "methods": {}
          },
          "PP_PLACEHOLDER_TYPE": {
            "type": "class",
            "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
            "methods": {}
          },
          "PROG_ID": {
            "type": "class",
            "doc": "One-off Enum-like object for progId values.\n\nIndicates the type of an OLE object in terms of the program used to open it.\n\nA member of this enumeration can be used in a `SlideShapes.add_ole_object()` call to\nspecify a Microsoft Office file-type (Excel, PowerPoint, or Word), which will\nthen not require several of the arguments required to embed other object types.\n\nExample::\n\n    from pptx.enum.shapes import PROG_ID\n    from pptx.util import Inches\n\n    embedded_xlsx_shape = slide.shapes.add_ole_object(\n        \"workbook.xlsx\", PROG_ID.XLSX, left=Inches(1), top=Inches(1)\n    )\n    assert embedded_xlsx_shape.ole_format.prog_id == \"Excel.Sheet.12\"",
            "methods": {}
          }
        }
      },
      "text": {
        "type": "module",
        "doc": "Enumerations used by text and related objects.",
        "members": {
          "BaseEnum": {
            "type": "class",
            "doc": "Base class for Enums that do not map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "BaseXmlEnum": {
            "type": "class",
            "doc": "Base class for Enums that also map XML attr values.\n\nThe enum's value will be an integer, corresponding to the integer assigned the\ncorresponding member in the MS API enum of the same name.",
            "methods": {}
          },
          "MSO_ANCHOR": {
            "type": "class",
            "doc": "Specifies the vertical alignment of text in a text frame.\n\nUsed with the `.vertical_anchor` property of the |TextFrame| object. Note that the\n`vertical_anchor` property can also have the value None, indicating there is no directly\nspecified vertical anchor setting and its effective value is inherited from its placeholder if\nit has one or from the theme. |None| may also be assigned to remove an explicitly specified\nvertical anchor setting.\n\nMS API Name: `MsoVerticalAnchor`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865255.aspx",
            "methods": {}
          },
          "MSO_AUTO_SIZE": {
            "type": "class",
            "doc": "Determines the type of automatic sizing allowed.\n\nThe following names can be used to specify the automatic sizing behavior used to fit a shape's\ntext within the shape bounding box, for example::\n\n    from pptx.enum.text import MSO_AUTO_SIZE\n\n    shape.text_frame.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE\n\nThe word-wrap setting of the text frame interacts with the auto-size setting to determine the\nspecific auto-sizing behavior.\n\nNote that `TextFrame.auto_size` can also be set to |None|, which removes the auto size setting\naltogether. This causes the setting to be inherited, either from the layout placeholder, in the\ncase of a placeholder shape, or from the theme.\n\nMS API Name: `MsoAutoSize`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865367(v=office.15).aspx",
            "methods": {}
          },
          "MSO_TEXT_UNDERLINE_TYPE": {
            "type": "class",
            "doc": "Indicates the type of underline for text. Used with\n:attr:`.Font.underline` to specify the style of text underlining.\n\nAlias: ``MSO_UNDERLINE``\n\nExample::\n\n    from pptx.enum.text import MSO_UNDERLINE\n\n    run.font.underline = MSO_UNDERLINE.DOUBLE_LINE\n\nMS API Name: `MsoTextUnderlineType`\n\nhttp://msdn.microsoft.com/en-us/library/aa432699.aspx",
            "methods": {}
          },
          "MSO_UNDERLINE": {
            "type": "class",
            "doc": "Indicates the type of underline for text. Used with\n:attr:`.Font.underline` to specify the style of text underlining.\n\nAlias: ``MSO_UNDERLINE``\n\nExample::\n\n    from pptx.enum.text import MSO_UNDERLINE\n\n    run.font.underline = MSO_UNDERLINE.DOUBLE_LINE\n\nMS API Name: `MsoTextUnderlineType`\n\nhttp://msdn.microsoft.com/en-us/library/aa432699.aspx",
            "methods": {}
          },
          "MSO_VERTICAL_ANCHOR": {
            "type": "class",
            "doc": "Specifies the vertical alignment of text in a text frame.\n\nUsed with the `.vertical_anchor` property of the |TextFrame| object. Note that the\n`vertical_anchor` property can also have the value None, indicating there is no directly\nspecified vertical anchor setting and its effective value is inherited from its placeholder if\nit has one or from the theme. |None| may also be assigned to remove an explicitly specified\nvertical anchor setting.\n\nMS API Name: `MsoVerticalAnchor`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865255.aspx",
            "methods": {}
          },
          "PP_ALIGN": {
            "type": "class",
            "doc": "Specifies the horizontal alignment for one or more paragraphs.\n\nAlias: `PP_ALIGN`\n\nExample::\n\n    from pptx.enum.text import PP_ALIGN\n\n    shape.paragraphs[0].alignment = PP_ALIGN.CENTER\n\nMS API Name: `PpParagraphAlignment`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745375(v=office.15).aspx",
            "methods": {}
          },
          "PP_PARAGRAPH_ALIGNMENT": {
            "type": "class",
            "doc": "Specifies the horizontal alignment for one or more paragraphs.\n\nAlias: `PP_ALIGN`\n\nExample::\n\n    from pptx.enum.text import PP_ALIGN\n\n    shape.paragraphs[0].alignment = PP_ALIGN.CENTER\n\nMS API Name: `PpParagraphAlignment`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745375(v=office.15).aspx",
            "methods": {}
          }
        }
      }
    }
  },
  "exc": {
    "type": "module",
    "doc": "Exceptions used with python-pptx.\n\nThe base exception class is PythonPptxError.",
    "members": {
      "InvalidXmlError": {
        "type": "class",
        "doc": "Raised when a value is encountered in the XML that is not valid according\nto the schema.",
        "methods": {}
      },
      "PackageNotFoundError": {
        "type": "class",
        "doc": "Raised when a package cannot be found at the specified path.",
        "methods": {}
      },
      "PythonPptxError": {
        "type": "class",
        "doc": "Generic error class.",
        "methods": {}
      }
    }
  },
  "exceptions": {
    "type": "module",
    "doc": "Exceptions used with python-pptx.\n\nThe base exception class is PythonPptxError.",
    "members": {
      "InvalidXmlError": {
        "type": "class",
        "doc": "Raised when a value is encountered in the XML that is not valid according\nto the schema.",
        "methods": {}
      },
      "PackageNotFoundError": {
        "type": "class",
        "doc": "Raised when a package cannot be found at the specified path.",
        "methods": {}
      },
      "PythonPptxError": {
        "type": "class",
        "doc": "Generic error class.",
        "methods": {}
      }
    }
  },
  "media": {
    "type": "module",
    "doc": "Objects related to images, audio, and video.",
    "members": {
      "CT": {
        "type": "class",
        "doc": "Content type URIs (like MIME-types) that specify a part's format.",
        "methods": {}
      },
      "IO": {
        "type": "class",
        "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
        "methods": {
          "close": "No documentation",
          "fileno": "No documentation",
          "flush": "No documentation",
          "isatty": "No documentation",
          "read": "No documentation",
          "readable": "No documentation",
          "readline": "No documentation",
          "readlines": "No documentation",
          "seek": "No documentation",
          "seekable": "No documentation",
          "tell": "No documentation",
          "truncate": "No documentation",
          "writable": "No documentation",
          "write": "No documentation",
          "writelines": "No documentation"
        }
      },
      "Video": {
        "type": "class",
        "doc": "Immutable value object representing a video such as MP4.",
        "methods": {}
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "opc": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "constants": {
        "type": "module",
        "doc": "Constant values related to the Open Packaging Convention.\n\nIn particular, this includes content (MIME) types and relationship types.",
        "members": {
          "CONTENT_TYPE": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "NAMESPACE": {
            "type": "class",
            "doc": "Constant values for OPC XML namespaces",
            "methods": {}
          },
          "RELATIONSHIP_TARGET_MODE": {
            "type": "class",
            "doc": "Open XML relationship target modes",
            "methods": {}
          },
          "RELATIONSHIP_TYPE": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          }
        }
      },
      "oxml": {
        "type": "module",
        "doc": "OPC-local oxml module to handle OPC-local concerns like relationship parsing.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Default": {
            "type": "class",
            "doc": "`<Default>` element.\n\nSpecifies the default content type to be applied to a part with the specified extension.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Override": {
            "type": "class",
            "doc": "`<Override>` element.\n\nSpecifies the content type to be applied for a part with the specified partname.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Relationship": {
            "type": "class",
            "doc": "`<Relationship>` element.\n\nRepresents a single relationship from a source to a target part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Relationships": {
            "type": "class",
            "doc": "`<Relationships>` element, the root element in a .rels file.",
            "methods": {
              "add_rel": "Add a child `<Relationship>` element with attributes set as specified.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Types": {
            "type": "class",
            "doc": "`<Types>` element.\n\nThe container element for Default and Override elements in [Content_Types].xml.",
            "methods": {
              "add_default": "Add a child `<Default>` element with attributes set to parameter values.",
              "add_override": "Add a child `<Override>` element with attributes set to parameter values.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "NS": {
            "type": "class",
            "doc": "Constant values for OPC XML namespaces",
            "methods": {}
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "RTM": {
            "type": "class",
            "doc": "Open XML relationship target modes",
            "methods": {}
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ST_ContentType": {
            "type": "class",
            "doc": "Has a pretty wicked regular expression it needs to match in the schema,\nbut figuring it's not worth the trouble or run time to identify\na programming error (as opposed to a user/runtime error).",
            "methods": {}
          },
          "ST_Extension": {
            "type": "class",
            "doc": "Has a regular expression it needs to match in the schema, but figuring\nit's not worth the trouble or run time to identify a programming error\n(as opposed to a user/runtime error).",
            "methods": {}
          },
          "ST_TargetMode": {
            "type": "class",
            "doc": "The valid values for the ``TargetMode`` attribute in a Relationship\nelement, either 'External' or 'Internal'.",
            "methods": {}
          },
          "XsdAnyUri": {
            "type": "class",
            "doc": "There's a regular expression this is supposed to meet but so far thinking\nspending cycles on validating wouldn't be worth it for the number of\nprogramming errors it would catch.",
            "methods": {}
          },
          "XsdId": {
            "type": "class",
            "doc": "String that must begin with a letter or underscore and cannot contain any\ncolons. Not fully validated because not used in external API.",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          }
        }
      },
      "package": {
        "type": "module",
        "doc": "Fundamental Open Packaging Convention (OPC) objects.\n\nThe :mod:`pptx.packaging` module coheres around the concerns of reading and writing\npresentations to and from a .pptx file.",
        "members": {
          "CT_Relationships": {
            "type": "class",
            "doc": "`<Relationships>` element, the root element in a .rels file.",
            "methods": {
              "add_rel": "Add a child `<Relationship>` element with attributes set as specified.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CaseInsensitiveDict": {
            "type": "class",
            "doc": "Mapping type like dict except it matches key without respect to case.\n\nFor example, D['A'] == D['a']. Note this is not general-purpose, just complete\nenough to satisfy opc package needs. It assumes str keys for example.",
            "methods": {}
          },
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "OpcPackage": {
            "type": "class",
            "doc": "Main API class for |python-opc|.\n\nA new instance is constructed by calling the :meth:`open` classmethod with a path to a package\nfile or file-like object containing a package (.pptx file).",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId`.",
              "iter_parts": "Generate exactly one reference to each part in the package.",
              "iter_rels": "Generate exactly one reference to each relationship in package.\n\nPerforms a depth-first traversal of the rels graph.",
              "next_partname": "Return |PackURI| next available partname matching `tmpl`.\n\n`tmpl` is a printf (%)-style template string containing a single replacement item, a '%d'\nto be used to insert the integer portion of the partname. Example:\n'/ppt/slides/slide%d.xml'",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "save": "Save this package to `pkg_file`.\n\n`file` can be either a path to a file (a string) or a file-like object.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          },
          "PackageReader": {
            "type": "class",
            "doc": "Provides access to package-parts of an OPC package with dict semantics.\n\nThe package may be in zip-format (a .pptx file) or expanded into a directory structure,\nperhaps by unzipping a .pptx file.",
            "methods": {
              "rels_xml_for": "Return optional rels item XML for `partname`.\n\nReturns `None` if no rels item is present for `partname`. `partname` is a |PackURI|\ninstance."
            }
          },
          "PackageWriter": {
            "type": "class",
            "doc": "Writes a zip-format OPC package to `pkg_file`.\n\n`pkg_file` can be either a path to a zip file (a string) or a file-like object. `pkg_rels` is\nthe |_Relationships| object containing relationships for the package. `parts` is a sequence of\n|Part| subtype instance to be written to the package.\n\nIts single API classmethod is :meth:`write`. This class is not intended to be instantiated.",
            "methods": {}
          },
          "Part": {
            "type": "class",
            "doc": "Base class for package parts.\n\nProvides common properties and methods, but intended to be subclassed in client code to\nimplement specific part behaviors. Also serves as the default class for parts that are not yet\ngiven specific behaviors.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PartFactory": {
            "type": "class",
            "doc": "Constructs a registered subtype of |Part|.\n\nClient code can register a subclass of |Part| to be used for a package blob based on its\ncontent type.",
            "methods": {}
          },
          "RT": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "RTM": {
            "type": "class",
            "doc": "Open XML relationship target modes",
            "methods": {}
          },
          "XmlPart": {
            "type": "class",
            "doc": "Base class for package parts containing an XML payload, which is most of them.\n\nProvides additional methods to the |Part| base class that take care of parsing and\nreserializing the XML payload and managing relationships to other parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "packuri": {
        "type": "module",
        "doc": "Provides the PackURI value type and known pack-URI strings such as PACKAGE_URI.",
        "members": {
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          }
        }
      },
      "serialized": {
        "type": "module",
        "doc": "API for reading/writing serialized Open Packaging Convention (OPC) package.",
        "members": {
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "CT_Types": {
            "type": "class",
            "doc": "`<Types>` element.\n\nThe container element for Default and Override elements in [Content_Types].xml.",
            "methods": {
              "add_default": "Add a child `<Default>` element with attributes set to parameter values.",
              "add_override": "Add a child `<Override>` element with attributes set to parameter values.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CaseInsensitiveDict": {
            "type": "class",
            "doc": "Mapping type like dict except it matches key without respect to case.\n\nFor example, D['A'] == D['a']. Note this is not general-purpose, just complete\nenough to satisfy opc package needs. It assumes str keys for example.",
            "methods": {}
          },
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          },
          "PackageNotFoundError": {
            "type": "class",
            "doc": "Raised when a package cannot be found at the specified path.",
            "methods": {}
          },
          "PackageReader": {
            "type": "class",
            "doc": "Provides access to package-parts of an OPC package with dict semantics.\n\nThe package may be in zip-format (a .pptx file) or expanded into a directory structure,\nperhaps by unzipping a .pptx file.",
            "methods": {
              "rels_xml_for": "Return optional rels item XML for `partname`.\n\nReturns `None` if no rels item is present for `partname`. `partname` is a |PackURI|\ninstance."
            }
          },
          "PackageWriter": {
            "type": "class",
            "doc": "Writes a zip-format OPC package to `pkg_file`.\n\n`pkg_file` can be either a path to a zip file (a string) or a file-like object. `pkg_rels` is\nthe |_Relationships| object containing relationships for the package. `parts` is a sequence of\n|Part| subtype instance to be written to the package.\n\nIts single API classmethod is :meth:`write`. This class is not intended to be instantiated.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "shared": {
        "type": "module",
        "doc": "Objects shared by modules in the pptx.opc sub-package.",
        "members": {
          "CaseInsensitiveDict": {
            "type": "class",
            "doc": "Mapping type like dict except it matches key without respect to case.\n\nFor example, D['A'] == D['a']. Note this is not general-purpose, just complete\nenough to satisfy opc package needs. It assumes str keys for example.",
            "methods": {}
          }
        }
      },
      "spec": {
        "type": "module",
        "doc": "Provides mappings that embody aspects of the Open XML spec ISO/IEC 29500.",
        "members": {
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          }
        }
      }
    }
  },
  "oxml": {
    "type": "module",
    "doc": "Initializes lxml parser, particularly the custom element classes.\n\nAlso makes available a handful of functions that wrap its typical uses.",
    "members": {
      "CT_AdjPoint2D": {
        "type": "class",
        "doc": "`a:pt` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ApplicationNonVisualDrawingProps": {
        "type": "class",
        "doc": "`p:nvPr` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_ph": "Return the ``<p:ph>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Area3DChart": {
        "type": "class",
        "doc": "``<c:area3DChart>`` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_AreaChart": {
        "type": "class",
        "doc": "``<c:areaChart>`` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_AxDataSource": {
        "type": "class",
        "doc": "``<c:cat>`` custom element class used in category charts to specify\ncategory labels and hierarchy.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_multiLvlStrRef": "Return the ``<c:multiLvlStrRef>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_AxisUnit": {
        "type": "class",
        "doc": "Used for `c:majorUnit` and `c:minorUnit` elements, and others.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Background": {
        "type": "class",
        "doc": "`p:bg` element.",
        "methods": {
          "add_noFill_bgPr": "Return a new `p:bgPr` element with noFill properties.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_bgPr": "Return the ``<p:bgPr>`` child element, newly added if not present.",
          "get_or_add_bgRef": "Return the ``<p:bgRef>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BackgroundProperties": {
        "type": "class",
        "doc": "`p:bgPr` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
          "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
          "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
          "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
          "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
          "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BarChart": {
        "type": "class",
        "doc": "``<c:barChart>`` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_gapWidth": "Return the ``<c:gapWidth>`` child element, newly added if not present.",
          "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
          "get_or_add_overlap": "Return the ``<c:overlap>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BarDir": {
        "type": "class",
        "doc": "``<c:barDir>`` child of a barChart element, specifying the orientation of\nthe bars, 'bar' if they are horizontal and 'col' if they are vertical.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Blip": {
        "type": "class",
        "doc": "<a:blip> element",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BlipFillProperties": {
        "type": "class",
        "doc": "Custom element class for <a:blipFill> element.",
        "methods": {
          "crop": "Set `a:srcRect` child to crop according to *cropping* values.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_blip": "Return the ``<a:blip>`` child element, newly added if not present.",
          "get_or_add_srcRect": "Return the ``<a:srcRect>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Boolean": {
        "type": "class",
        "doc": "Common complex type used for elements having a True/False value.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Boolean_Explicit": {
        "type": "class",
        "doc": "Always spells out the `val` attribute, e.g. `val=1`.\n\nAt least one boolean element is improperly interpreted by one or more\nversions of PowerPoint. The `c:overlay` element is interpreted as |False|\nwhen no `val` attribute is present, contrary to the behavior described in\nthe schema. A remedy for this is to interpret a missing `val` attribute\nas |True| (consistent with the spec), but always write the attribute\nwhenever there is occasion for changing the element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BubbleChart": {
        "type": "class",
        "doc": "``<c:bubbleChart>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_bubble3D": "Return the ``<c:bubble3D>`` child element, newly added if not present.",
          "get_or_add_bubbleScale": "Return the ``<c:bubbleScale>`` child element, newly added if not present.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_BubbleScale": {
        "type": "class",
        "doc": "``<c:bubbleScale>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_CatAx": {
        "type": "class",
        "doc": "`c:catAx` element, defining a category axis.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
          "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
          "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
          "get_or_add_lblOffset": "Return the ``<c:lblOffset>`` child element, newly added if not present.",
          "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
          "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
          "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
          "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
          "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
          "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Chart": {
        "type": "class",
        "doc": "`c:chart` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_autoTitleDeleted": "Return the ``<c:autoTitleDeleted>`` child element, newly added if not present.",
          "get_or_add_legend": "Return the ``<c:legend>`` child element, newly added if not present.",
          "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "new_chart": "Return a new `c:chart` element.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ChartLines": {
        "type": "class",
        "doc": "Used for `c:majorGridlines` and `c:minorGridlines`.\n\nSpecifies gridlines visual properties such as color and width.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ChartSpace": {
        "type": "class",
        "doc": "`c:chartSpace` root element of a chart part.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_date1904": "Return the ``<c:date1904>`` child element, newly added if not present.",
          "get_or_add_externalData": "Return the ``<c:externalData>`` child element, newly added if not present.",
          "get_or_add_style": "Return the ``<c:style>`` child element, newly added if not present.",
          "get_or_add_title": "Return the `c:title` grandchild, newly created if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Color": {
        "type": "class",
        "doc": "Custom element class for `a:fgClr`, `a:bgClr` and perhaps others.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
          "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
          "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
          "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_CommonSlideData": {
        "type": "class",
        "doc": "`p:cSld` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_bg": "Return the ``<p:bg>`` child element, newly added if not present.",
          "get_or_add_bgPr": "Return `p:bg/p:bgPr` grandchild.\n\nIf no such grandchild is present, any existing `p:bg` child is first removed and a new\ndefault `p:bg` with noFill settings is added.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Connection": {
        "type": "class",
        "doc": "A `a:stCxn` or `a:endCxn` element.\n\nSpecifies a connection between an end-point of a connector and a shape connection point.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Connector": {
        "type": "class",
        "doc": "A line/connector shape `p:cxnSp` element",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ConnectorNonVisual": {
        "type": "class",
        "doc": "`p:nvCxnSpPr` element, container for the non-visual properties of\na connector, such as name, id, etc.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_CoreProperties": {
        "type": "class",
        "doc": "`cp:coreProperties` element.\n\nThe root element of the Core Properties part stored as `/docProps/core.xml`. Implements many\nof the Dublin Core document metadata elements. String elements resolve to an empty string ('')\nif the element is not present in the XML. String elements are limited in length to 255 unicode\ncharacters.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_category": "Return the ``<cp:category>`` child element, newly added if not present.",
          "get_or_add_contentStatus": "Return the ``<cp:contentStatus>`` child element, newly added if not present.",
          "get_or_add_created": "Return the ``<dcterms:created>`` child element, newly added if not present.",
          "get_or_add_creator": "Return the ``<dc:creator>`` child element, newly added if not present.",
          "get_or_add_description": "Return the ``<dc:description>`` child element, newly added if not present.",
          "get_or_add_identifier": "Return the ``<dc:identifier>`` child element, newly added if not present.",
          "get_or_add_keywords": "Return the ``<cp:keywords>`` child element, newly added if not present.",
          "get_or_add_language": "Return the ``<dc:language>`` child element, newly added if not present.",
          "get_or_add_lastModifiedBy": "Return the ``<cp:lastModifiedBy>`` child element, newly added if not present.",
          "get_or_add_lastPrinted": "Return the ``<cp:lastPrinted>`` child element, newly added if not present.",
          "get_or_add_modified": "Return the ``<dcterms:modified>`` child element, newly added if not present.",
          "get_or_add_revision": "Return the ``<cp:revision>`` child element, newly added if not present.",
          "get_or_add_subject": "Return the ``<dc:subject>`` child element, newly added if not present.",
          "get_or_add_title": "Return the ``<dc:title>`` child element, newly added if not present.",
          "get_or_add_version": "Return the ``<cp:version>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "new_coreProperties": "Return a new `cp:coreProperties` element",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Crosses": {
        "type": "class",
        "doc": "`c:crosses` element, specifying where the other axis crosses this one.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_CustomGeometry2D": {
        "type": "class",
        "doc": "`a:custGeom` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_pathLst": "Return the ``<a:pathLst>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DLbl": {
        "type": "class",
        "doc": "``<c:dLbl>`` element specifying the properties of the data label for an\nindividual data point.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
          "get_or_add_rich": "Return the `c:rich` descendant representing the text frame of the\ndata label, newly created if not present. Any existing `c:strRef`\nelement is removed along with its contents.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "get_or_add_tx_rich": "Return the `c:tx[c:rich]` subtree, newly created if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "remove_tx_rich": "Remove any `c:tx[c:rich]` child, or do nothing if not present.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DLblPos": {
        "type": "class",
        "doc": "``<c:dLblPos>`` element specifying the positioning of a data label with\nrespect to its data point.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DLbls": {
        "type": "class",
        "doc": "`c:dLbls` element specifying properties for a set of data labels.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_dLbl_for_point": "Return the `c:dLbl` child representing the label for the data point\nat index *idx*.",
          "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
          "get_or_add_dLbl_for_point": "Return the `c:dLbl` element representing the label of the point at\nindex *idx*.",
          "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
          "get_or_add_showCatName": "Return the ``<c:showCatName>`` child element, newly added if not present.",
          "get_or_add_showLegendKey": "Return the ``<c:showLegendKey>`` child element, newly added if not present.",
          "get_or_add_showPercent": "Return the ``<c:showPercent>`` child element, newly added if not present.",
          "get_or_add_showSerName": "Return the ``<c:showSerName>`` child element, newly added if not present.",
          "get_or_add_showVal": "Return the ``<c:showVal>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DPt": {
        "type": "class",
        "doc": "``<c:dPt>`` custom element class, containing visual properties for a data\npoint.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_marker": "Return the ``<c:marker>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DateAx": {
        "type": "class",
        "doc": "`c:dateAx` element, defining a date (category) axis.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
          "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
          "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
          "get_or_add_lblOffset": "Return the ``<c:lblOffset>`` child element, newly added if not present.",
          "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
          "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
          "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
          "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
          "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
          "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Double": {
        "type": "class",
        "doc": "Used for floating point values.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_DoughnutChart": {
        "type": "class",
        "doc": "``<c:doughnutChart>`` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ExternalData": {
        "type": "class",
        "doc": "`<c:externalData>` element, defining link to embedded Excel package part\ncontaining the chart data.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_autoUpdate": "Return the ``<c:autoUpdate>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GapAmount": {
        "type": "class",
        "doc": "``<c:gapWidth>`` child of ``<c:barChart>`` element, also used for other\npurposes like error bars.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GeomGuide": {
        "type": "class",
        "doc": "`a:gd` custom element class.\n\nDefines a \"guide\", corresponding to a yellow diamond-shaped handle on an autoshape.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GeomGuideList": {
        "type": "class",
        "doc": "`a:avLst` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GradientFillProperties": {
        "type": "class",
        "doc": "`a:gradFill` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
          "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
          "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GradientStop": {
        "type": "class",
        "doc": "`a:gs` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
          "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
          "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
          "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GradientStopList": {
        "type": "class",
        "doc": "`a:gsLst` custom element class.",
        "methods": {
          "add_gs": "Add a new ``<a:gs>`` child element unconditionally, inserted in the correct sequence.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GraphicalObject": {
        "type": "class",
        "doc": "`a:graphic` element.\n\nThe container for the reference to or definition of the framed graphical object (table, chart,\netc.).",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GraphicalObjectData": {
        "type": "class",
        "doc": "`p:graphicData` element.\n\nThe direct container for a table, a chart, or another graphical object.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_chart": "Return the ``<c:chart>`` child element, newly added if not present.",
          "get_or_add_tbl": "Return the ``<a:tbl>`` child element, newly added if not present.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GraphicalObjectFrame": {
        "type": "class",
        "doc": "`p:graphicFrame` element.\n\nA container for a table, a chart, or another graphical object.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the required `p:xfrm` child element.\n\nOverrides version on BaseShapeElement.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GraphicalObjectFrameNonVisual": {
        "type": "class",
        "doc": "`p:nvGraphicFramePr` element.\n\nThis contains the non-visual properties of a graphic frame, such as name, id, etc.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GroupFillProperties": {
        "type": "class",
        "doc": "`a:grpFill` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GroupShape": {
        "type": "class",
        "doc": "Used for shape tree (`p:spTree`) as well as the group shape (`p:grpSp`) elements.",
        "methods": {
          "add_autoshape": "Return new `p:sp` appended to the group/shapetree with specified attributes.",
          "add_cxnSp": "Return new `p:cxnSp` appended to the group/shapetree with the specified attribues.",
          "add_freeform_sp": "Append a new freeform `p:sp` with specified position and size.",
          "add_grpSp": "Return `p:grpSp` element newly appended to this shape tree.\n\nThe element contains no sub-shapes, is positioned at (0, 0), and has\nwidth and height of zero.",
          "add_pic": "Append a `p:pic` shape to the group/shapetree having properties as specified in call.",
          "add_placeholder": "Append a newly-created placeholder `p:sp` shape having the specified properties.",
          "add_table": "Append a `p:graphicFrame` shape containing a table as specified in call.",
          "add_textbox": "Append a newly-created textbox `p:sp` shape having the specified position and size.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.",
          "insert_element_before": "No documentation",
          "iter_ph_elms": "Generate each placeholder shape child element in document order.",
          "iter_shape_elms": "Generate each child of this `p:spTree` element that corresponds to a shape.\n\nItems appear in XML document order.",
          "recalculate_extents": "Adjust x, y, cx, and cy to incorporate all contained shapes.\n\nThis would typically be called when a contained shape is added,\nremoved, or its position or size updated.\n\nThis method is recursive \"upwards\" since a change in a group shape\ncan change the position and size of its containing group.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GroupShapeNonVisual": {
        "type": "class",
        "doc": "`p:nvGrpSpPr` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_GroupShapeProperties": {
        "type": "class",
        "doc": "p:grpSpPr element",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_effectLst": "Return the ``<a:effectLst>`` child element, newly added if not present.",
          "get_or_add_xfrm": "Return the ``<a:xfrm>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Grouping": {
        "type": "class",
        "doc": "``<c:grouping>`` child of an xChart element, specifying a value like\n'clustered' or 'stacked'. Also used for variants with the same tag name\nlike CT_BarGrouping.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_HslColor": {
        "type": "class",
        "doc": "Custom element class for <a:hslClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Hyperlink": {
        "type": "class",
        "doc": "Custom element class for <a:hlinkClick> elements.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Layout": {
        "type": "class",
        "doc": "``<c:layout>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_manualLayout": "Return the ``<c:manualLayout>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LayoutMode": {
        "type": "class",
        "doc": "Used for ``<c:xMode>``, ``<c:yMode>``, ``<c:wMode>``, and ``<c:hMode>``\nchild elements of CT_ManualLayout.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LblOffset": {
        "type": "class",
        "doc": "`c:lblOffset` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Legend": {
        "type": "class",
        "doc": "``<c:legend>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_layout": "Return the ``<c:layout>`` child element, newly added if not present.",
          "get_or_add_legendPos": "Return the ``<c:legendPos>`` child element, newly added if not present.",
          "get_or_add_overlay": "Return the ``<c:overlay>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LegendPos": {
        "type": "class",
        "doc": "``<c:legendPos>`` element specifying position of legend with respect to\nchart as a member of ST_LegendPos.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LineChart": {
        "type": "class",
        "doc": "``<c:lineChart>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LineProperties": {
        "type": "class",
        "doc": "Custom element class for <a:ln> element",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_custDash": "Return the ``<a:custDash>`` child element, newly added if not present.",
          "get_or_add_prstDash": "Return the ``<a:prstDash>`` child element, newly added if not present.",
          "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
          "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
          "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
          "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_LinearShadeProperties": {
        "type": "class",
        "doc": "`a:lin` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Lvl": {
        "type": "class",
        "doc": "``<c:lvl>`` custom element class used in multi-level categories to\nspecify a level of hierarchy.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ManualLayout": {
        "type": "class",
        "doc": "``<c:manualLayout>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_x": "Return the ``<c:x>`` child element, newly added if not present.",
          "get_or_add_xMode": "Return the ``<c:xMode>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Marker": {
        "type": "class",
        "doc": "`c:marker` custom element class, containing visual properties for a data\npoint marker on line-type charts.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_size": "Return the ``<c:size>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_symbol": "Return the ``<c:symbol>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_MarkerSize": {
        "type": "class",
        "doc": "`c:size` custom element class, specifying the size (in points) of a data\npoint marker for a line, XY, or radar chart.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_MarkerStyle": {
        "type": "class",
        "doc": "`c:symbol` custom element class, specifying the shape of a data point\nmarker for a line, XY, or radar chart.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NoFillProperties": {
        "type": "class",
        "doc": "`a:noFill` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NonVisualConnectorProperties": {
        "type": "class",
        "doc": "`p:cNvCxnSpPr` element, container for the non-visual properties specific\nto a connector shape, such as connections and connector locking.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_endCxn": "Return the ``<a:endCxn>`` child element, newly added if not present.",
          "get_or_add_stCxn": "Return the ``<a:stCxn>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NonVisualDrawingProps": {
        "type": "class",
        "doc": "`p:cNvPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_hlinkClick": "Return the ``<a:hlinkClick>`` child element, newly added if not present.",
          "get_or_add_hlinkHover": "Return the ``<a:hlinkHover>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NonVisualDrawingShapeProps": {
        "type": "class",
        "doc": "`p:cNvSpPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_spLocks": "Return the ``<a:spLocks>`` child element, newly added if not present.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NotesMaster": {
        "type": "class",
        "doc": "`p:notesMaster` element, root of a notes master part.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NotesSlide": {
        "type": "class",
        "doc": "`p:notes` element, root of a notes slide part.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NumDataSource": {
        "type": "class",
        "doc": "``<c:yVal>`` custom element class used in XY and bubble charts, and\nperhaps others.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "pt_v": "Return the Y value for data point *idx* in this cache, or None if no\nvalue is present for that data point.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_NumFmt": {
        "type": "class",
        "doc": "``<c:numFmt>`` element specifying the formatting for number labels on a\ntick mark or data point.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_OfficeStyleSheet": {
        "type": "class",
        "doc": "``<a:theme>`` element, root of a theme part",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_OleObject": {
        "type": "class",
        "doc": "`p:oleObj` element, container for an OLE object (e.g. Excel file).\n\nAn OLE object can be either linked or embedded (hence the name).",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Orientation": {
        "type": "class",
        "doc": "`c:xAx/c:scaling/c:orientation` element, defining category order.\n\nUsed to reverse the order categories appear in on a bar chart so they start at the\ntop rather than the bottom. Because we read top-to-bottom, the default way looks odd\nto many and perhaps most folks. Also applicable to value and date axes.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Overlap": {
        "type": "class",
        "doc": "``<c:overlap>`` element specifying bar overlap as an integer percentage\nof bar width, in range -100 to 100.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Path2D": {
        "type": "class",
        "doc": "`a:path` custom element class.",
        "methods": {
          "add_close": "Return a newly created `a:close` element.\n\nThe new `a:close` element is appended to this `a:path` element.",
          "add_lnTo": "Return a newly created `a:lnTo` subtree with end point *(x, y)*.\n\nThe new `a:lnTo` element is appended to this `a:path` element.",
          "add_moveTo": "Return a newly created `a:moveTo` subtree with point `(x, y)`.\n\nThe new `a:moveTo` element is appended to this `a:path` element.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Path2DClose": {
        "type": "class",
        "doc": "`a:close` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Path2DLineTo": {
        "type": "class",
        "doc": "`a:lnTo` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_pt": "Return the ``<a:pt>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Path2DList": {
        "type": "class",
        "doc": "`a:pathLst` custom element class.",
        "methods": {
          "add_path": "Return a newly created `a:path` child element.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Path2DMoveTo": {
        "type": "class",
        "doc": "`a:moveTo` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_pt": "Return the ``<a:pt>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PatternFillProperties": {
        "type": "class",
        "doc": "`a:pattFill` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_bgClr": "Return the ``<a:bgClr>`` child element, newly added if not present.",
          "get_or_add_fgClr": "Return the ``<a:fgClr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Percentage": {
        "type": "class",
        "doc": "Custom element class for <a:lumMod> and <a:lumOff> elements.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Picture": {
        "type": "class",
        "doc": "`p:pic` element.\n\nRepresents a picture shape (an image placement on a slide).",
        "methods": {
          "crop_to_fit": "Set cropping values in `p:blipFill/a:srcRect` such that an image of\n*image_size* will stretch to exactly fit *view_size* when its aspect\nratio is preserved.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_ln": "Return the <a:ln> grandchild element, newly added if not present.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PictureNonVisual": {
        "type": "class",
        "doc": "``<p:nvPicPr>`` element, containing non-visual properties for a picture\nshape.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PieChart": {
        "type": "class",
        "doc": "``<c:pieChart>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Placeholder": {
        "type": "class",
        "doc": "`p:ph` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PlotArea": {
        "type": "class",
        "doc": "``<c:plotArea>`` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each of the `c:ser` elements in this chart, ordered first by\nthe document order of the containing xChart element, then by their\nordering within the xChart element (not necessarily document order).",
          "iter_xCharts": "Generate each xChart child element in document.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Point2D": {
        "type": "class",
        "doc": "Custom element class for <a:off> element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PositiveSize2D": {
        "type": "class",
        "doc": "Custom element class for <a:ext> element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Presentation": {
        "type": "class",
        "doc": "`p:presentation` element, root of the Presentation part stored as `/ppt/presentation.xml`.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_sldIdLst": "Return the ``<p:sldIdLst>`` child element, newly added if not present.",
          "get_or_add_sldMasterIdLst": "Return the ``<p:sldMasterIdLst>`` child element, newly added if not present.",
          "get_or_add_sldSz": "Return the ``<p:sldSz>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PresetColor": {
        "type": "class",
        "doc": "Custom element class for <a:prstClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PresetGeometry2D": {
        "type": "class",
        "doc": "`a:prstGeom` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_avLst": "Return the ``<a:avLst>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "rewrite_guides": "Replace any `a:gd` element children of `a:avLst` with ones forme from `guides`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_PresetLineDashProperties": {
        "type": "class",
        "doc": "`a:prstDash` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_RadarChart": {
        "type": "class",
        "doc": "``<c:radarChart>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_RegularTextRun": {
        "type": "class",
        "doc": "`a:r` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_RelativeRect": {
        "type": "class",
        "doc": "`a:srcRect` element and perhaps others.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SRgbColor": {
        "type": "class",
        "doc": "Custom element class for <a:srgbClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ScRgbColor": {
        "type": "class",
        "doc": "Custom element class for <a:scrgbClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Scaling": {
        "type": "class",
        "doc": "`c:scaling` element.\n\nDefines axis scale characteristics such as maximum value, log vs. linear, etc.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_max": "Return the ``<c:max>`` child element, newly added if not present.",
          "get_or_add_min": "Return the ``<c:min>`` child element, newly added if not present.",
          "get_or_add_orientation": "Return the ``<c:orientation>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ScatterChart": {
        "type": "class",
        "doc": "``<c:scatterChart>`` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SchemeColor": {
        "type": "class",
        "doc": "Custom element class for <a:schemeClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SeriesComposite": {
        "type": "class",
        "doc": "``<c:ser>`` custom element class. Note there are several different series\nelement types in the schema, such as ``CT_LineSer`` and ``CT_BarSer``,\nbut they all share the same tag name. This class acts as a composite and\ndepends on the caller not to do anything invalid for a series belonging\nto a particular plot type.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_dLbl": "Return the `c:dLbl` element representing the label for the data point\nat offset *idx* in this series, or |None| if not present.",
          "get_or_add_bubbleSize": "Return the ``<c:bubbleSize>`` child element, newly added if not present.",
          "get_or_add_cat": "Return the ``<c:cat>`` child element, newly added if not present.",
          "get_or_add_dLbl": "Return the `c:dLbl` element representing the label of the point at\noffset *idx* in this series, newly created if not yet present.",
          "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
          "get_or_add_dPt_for_point": "Return the `c:dPt` child representing the visual properties of the\ndata point at index *idx*.",
          "get_or_add_invertIfNegative": "Return the ``<c:invertIfNegative>`` child element, newly added if not present.",
          "get_or_add_marker": "Return the ``<c:marker>`` child element, newly added if not present.",
          "get_or_add_smooth": "Return the ``<c:smooth>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
          "get_or_add_val": "Return the ``<c:val>`` child element, newly added if not present.",
          "get_or_add_xVal": "Return the ``<c:xVal>`` child element, newly added if not present.",
          "get_or_add_yVal": "Return the ``<c:yVal>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Shape": {
        "type": "class",
        "doc": "`p:sp` custom element class.",
        "methods": {
          "add_path": "No documentation",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_ln": "Return the `a:ln` grandchild element, newly added if not present.",
          "get_or_add_txBody": "Return the ``<p:txBody>`` child element, newly added if not present.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "new_autoshape_sp": "Return a new `p:sp` element tree configured as a base auto shape.",
          "new_freeform_sp": "Return new `p:sp` element tree configured as freeform shape.\n\nThe returned shape has a `a:custGeom` subtree but no paths in its\npath list.",
          "new_placeholder_sp": "Return a new `p:sp` element tree configured as a placeholder shape.",
          "new_textbox_sp": "Return a new `p:sp` element tree configured as a base textbox shape.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ShapeNonVisual": {
        "type": "class",
        "doc": "`p:nvSpPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ShapeProperties": {
        "type": "class",
        "doc": "Custom element class for `p:spPr` element.\n\nShared by `p:sp`, `p:cxnSp`,  and `p:pic` elements as well as a few more obscure ones.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_custGeom": "Return the ``<a:custGeom>`` child element, newly added if not present.",
          "get_or_add_effectLst": "Return the ``<a:effectLst>`` child element, newly added if not present.",
          "get_or_add_ln": "Return the ``<a:ln>`` child element, newly added if not present.",
          "get_or_add_prstGeom": "Return the ``<a:prstGeom>`` child element, newly added if not present.",
          "get_or_add_xfrm": "Return the ``<a:xfrm>`` child element, newly added if not present.",
          "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
          "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
          "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
          "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
          "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
          "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Slide": {
        "type": "class",
        "doc": "`p:sld` element, root element of a slide part (XML document).",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_childTnLst": "Return parent element for a new `p:video` child element.\n\nThe `p:video` element causes play controls to appear under a video\nshape (pic shape containing video). There can be more than one video\nshape on a slide, which causes the precondition to vary. It needs to\nhandle the case when there is no `p:sld/p:timing` element and when\nthat element already exists. If the case isn't simple, it just nukes\nwhat's there and adds a fresh one. This could theoretically remove\ndesired existing timing information, but there isn't any evidence\navailable to me one way or the other, so I've taken the simple\napproach.",
          "get_or_add_clrMapOvr": "Return the ``<p:clrMapOvr>`` child element, newly added if not present.",
          "get_or_add_timing": "Return the ``<p:timing>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideId": {
        "type": "class",
        "doc": "`p:sldId` element.\n\nDirect child of `p:sldIdLst` that contains an `rId` reference to a slide in the presentation.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideIdList": {
        "type": "class",
        "doc": "`p:sldIdLst` element.\n\nDirect child of <p:presentation> that contains a list of the slide parts in the presentation.",
        "methods": {
          "add_sldId": "Create and return a reference to a new `p:sldId` child element.\n\nThe new `p:sldId` element has its r:id attribute set to `rId`.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideLayout": {
        "type": "class",
        "doc": "`p:sldLayout` element, root of a slide layout part.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideLayoutIdList": {
        "type": "class",
        "doc": "`p:sldLayoutIdLst` element, child of `p:sldMaster`.\n\nContains references to the slide layouts that inherit from the slide master.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideLayoutIdListEntry": {
        "type": "class",
        "doc": "`p:sldLayoutId` element, child of `p:sldLayoutIdLst`.\n\nContains a reference to a slide layout.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideMaster": {
        "type": "class",
        "doc": "`p:sldMaster` element, root of a slide master part.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_sldLayoutIdLst": "Return the ``<p:sldLayoutIdLst>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideMasterIdList": {
        "type": "class",
        "doc": "`p:sldMasterIdLst` element.\n\nChild of `p:presentation` containing references to the slide masters that belong to the\npresentation.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideMasterIdListEntry": {
        "type": "class",
        "doc": "``<p:sldMasterId>`` element, child of ``<p:sldMasterIdLst>`` containing\na reference to a slide master.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideSize": {
        "type": "class",
        "doc": "`p:sldSz` element.\n\nDirect child of <p:presentation> that contains the width and height of slides in the\npresentation.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SlideTiming": {
        "type": "class",
        "doc": "`p:timing` element, specifying animations and timed behaviors.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_tnLst": "Return the ``<p:tnLst>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SolidColorFillProperties": {
        "type": "class",
        "doc": "`a:solidFill` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
          "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
          "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
          "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
          "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_StrVal_NumVal_Composite": {
        "type": "class",
        "doc": "``<c:pt>`` element, can be either CT_StrVal or CT_NumVal complex type.\nUsing this class for both, differentiating as needed.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Style": {
        "type": "class",
        "doc": "``<c:style>`` element; defines the chart style.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_SystemColor": {
        "type": "class",
        "doc": "Custom element class for <a:sysClr> element.",
        "methods": {
          "add_lumMod": "Return a newly added <a:lumMod> child element.",
          "add_lumOff": "Return a newly added <a:lumOff> child element.",
          "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
          "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TLMediaNodeVideo": {
        "type": "class",
        "doc": "`p:video` element, specifying video media details.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Table": {
        "type": "class",
        "doc": "`a:tbl` custom element class",
        "methods": {
          "add_tr": "Return a newly created `a:tr` child element having its `h` attribute set to `height`.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_tblPr": "Return the ``<a:tblPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "iter_tcs": "Generate each `a:tc` element in this tbl.\n\n`a:tc` elements are generated left-to-right, top-to-bottom.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "tc": "Return `a:tc` element at `row_idx`, `col_idx`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableCell": {
        "type": "class",
        "doc": "`a:tc` custom element class",
        "methods": {
          "append_ps_from": "Append `a:p` elements taken from `spanned_tc`.\n\nAny non-empty paragraph elements in `spanned_tc` are removed and appended to the\ntext-frame of this cell. If `spanned_tc` is left with no content after this process, a\nsingle empty `a:p` element is added to ensure the cell is compliant with the spec.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_tcPr": "Return the ``<a:tcPr>`` child element, newly added if not present.",
          "get_or_add_txBody": "Return the ``<a:txBody>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableCellProperties": {
        "type": "class",
        "doc": "`a:tcPr` custom element class",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
          "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
          "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
          "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
          "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
          "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableCol": {
        "type": "class",
        "doc": "`a:gridCol` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableGrid": {
        "type": "class",
        "doc": "`a:tblGrid` custom element class.",
        "methods": {
          "add_gridCol": "A newly appended `a:gridCol` child element having its `w` attribute set to `width`.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableProperties": {
        "type": "class",
        "doc": "`a:tblPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TableRow": {
        "type": "class",
        "doc": "`a:tr` custom element class.",
        "methods": {
          "add_tc": "A newly added minimal valid `a:tc` child element.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextBody": {
        "type": "class",
        "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
        "methods": {
          "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
          "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextBodyProperties": {
        "type": "class",
        "doc": "`a:bodyPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_change_to_noAutofit": "Return the ``<a:noAutofit>`` child, replacing any other group element if found.",
          "get_or_change_to_normAutofit": "Return the ``<a:normAutofit>`` child, replacing any other group element if found.",
          "get_or_change_to_spAutoFit": "Return the ``<a:spAutoFit>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextCharacterProperties": {
        "type": "class",
        "doc": "Custom element class for `a:rPr`, `a:defRPr`, and `a:endParaRPr`.\n\n'rPr' is short for 'run properties', and it corresponds to the |Font| proxy class.",
        "methods": {
          "add_hlinkClick": "Add an `a:hlinkClick` child element with r:id attribute set to `rId`.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_hlinkClick": "Return the ``<a:hlinkClick>`` child element, newly added if not present.",
          "get_or_add_latin": "Return the ``<a:latin>`` child element, newly added if not present.",
          "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
          "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
          "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
          "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
          "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
          "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextField": {
        "type": "class",
        "doc": "`a:fld` field element, for either a slide number or date field.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
          "get_or_add_t": "Return the ``<a:t>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextFont": {
        "type": "class",
        "doc": "Custom element class for `a:latin`, `a:ea`, `a:cs`, and `a:sym`.\n\nThese occur as child elements of CT_TextCharacterProperties, e.g. `a:rPr`.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextLineBreak": {
        "type": "class",
        "doc": "`a:br` line break element",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextNormalAutofit": {
        "type": "class",
        "doc": "`a:normAutofit` element specifying fit text to shape font reduction, etc.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextParagraph": {
        "type": "class",
        "doc": "`a:p` custom element class",
        "methods": {
          "add_br": "Return a newly appended `a:br` element.",
          "add_r": "Return a newly appended `a:r` element.",
          "append_text": "Append `a:r` and `a:br` elements to `p` based on `text`.\n\n        Any `\n` or `\u000b` (vertical-tab) characters in `text` delimit `a:r` (run) elements and\n        themselves are translated to `a:br` (line-break) elements. The vertical-tab character\n        appears in clipboard text from PowerPoint at \"soft\" line-breaks (new-line, but not new\n        paragraph).\n        ",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_endParaRPr": "Return the ``<a:endParaRPr>`` child element, newly added if not present.",
          "get_or_add_pPr": "Return the ``<a:pPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextParagraphProperties": {
        "type": "class",
        "doc": "`a:pPr` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_defRPr": "Return the ``<a:defRPr>`` child element, newly added if not present.",
          "get_or_add_lnSpc": "Return the ``<a:lnSpc>`` child element, newly added if not present.",
          "get_or_add_spcAft": "Return the ``<a:spcAft>`` child element, newly added if not present.",
          "get_or_add_spcBef": "Return the ``<a:spcBef>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextSpacing": {
        "type": "class",
        "doc": "Used for `a:lnSpc`, `a:spcBef`, and `a:spcAft` elements.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_spcPct": "Return the ``<a:spcPct>`` child element, newly added if not present.",
          "get_or_add_spcPts": "Return the ``<a:spcPts>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "set_spcPct": "Set spacing to `value` lines, e.g. 1.75 lines.\n\nA ./a:spcPts child is removed if present.",
          "set_spcPts": "Set spacing to `value` points. A ./a:spcPct child is removed if present.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextSpacingPercent": {
        "type": "class",
        "doc": "`a:spcPct` element, specifying spacing in thousandths of a percent in its `val` attribute.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TextSpacingPoint": {
        "type": "class",
        "doc": "`a:spcPts` element, specifying spacing in centipoints in its `val` attribute.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TickLblPos": {
        "type": "class",
        "doc": "`c:tickLblPos` element.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TickMark": {
        "type": "class",
        "doc": "Used for `c:minorTickMark` and `c:majorTickMark`.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_TimeNodeList": {
        "type": "class",
        "doc": "`p:tnLst` or `p:childTnList` element.",
        "methods": {
          "add_video": "Add a new `p:video` child element for movie having *shape_id*.",
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Title": {
        "type": "class",
        "doc": "`c:title` custom element class.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
          "get_or_add_tx_rich": "Return `c:tx/c:rich`, newly created if not present.\n\nReturn the `c:rich` grandchild at `c:tx/c:rich`. Both the `c:tx` and\n`c:rich` elements are created if not already present. Any\n`c:tx/c:strRef` element is removed. (Such an element would contain\na cell reference for the axis title text in the chart's Excel\nworksheet.)",
          "insert_element_before": "No documentation",
          "new_title": "Return \"loose\" `c:title` element containing default children.",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Transform2D": {
        "type": "class",
        "doc": "`a:xfrm` custom element class.\n\nNOTE: this is a composite including CT_GroupTransform2D, which appears\nwith the `a:xfrm` tag in a group shape (including a slide `p:spTree`).",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_chExt": "Return the ``<a:chExt>`` child element, newly added if not present.",
          "get_or_add_chOff": "Return the ``<a:chOff>`` child element, newly added if not present.",
          "get_or_add_ext": "Return the ``<a:ext>`` child element, newly added if not present.",
          "get_or_add_off": "Return the ``<a:off>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_Tx": {
        "type": "class",
        "doc": "``<c:tx>`` element containing the text for a label on a data point or\nother chart item.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_rich": "Return the ``<c:rich>`` child element, newly added if not present.",
          "get_or_add_strRef": "Return the ``<c:strRef>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_UnsignedInt": {
        "type": "class",
        "doc": "``<c:idx>`` element and others.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "CT_ValAx": {
        "type": "class",
        "doc": "`c:valAx` element, defining a value axis.",
        "methods": {
          "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
          "get_or_add_crossAx": "Return the ``<c:crossAx>`` child element, newly added if not present.",
          "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
          "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
          "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
          "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
          "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
          "get_or_add_majorUnit": "Return the ``<c:majorUnit>`` child element, newly added if not present.",
          "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
          "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
          "get_or_add_minorUnit": "Return the ``<c:minorUnit>`` child element, newly added if not present.",
          "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
          "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
          "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
          "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
          "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
          "insert_element_before": "No documentation",
          "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
          "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
        }
      },
      "NamespacePrefixedTag": {
        "type": "class",
        "doc": "Value object that knows the semantics of an XML tag having a namespace prefix.",
        "methods": {}
      },
      "action": {
        "type": "module",
        "doc": "lxml custom element classes for text-related XML elements.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Hyperlink": {
            "type": "class",
            "doc": "Custom element class for <a:hlinkClick> elements.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "XsdString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          }
        }
      },
      "chart": {
        "type": "module",
        "doc": "No documentation",
        "members": {
          "axis": {
            "type": "module",
            "doc": "Axis-related oxml objects.",
            "members": {
              "BaseAxisElement": {
                "type": "class",
                "doc": "Base class for catAx, dateAx, valAx, and perhaps other axis elements.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_AxisUnit": {
                "type": "class",
                "doc": "Used for `c:majorUnit` and `c:minorUnit` elements, and others.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_CatAx": {
                "type": "class",
                "doc": "`c:catAx` element, defining a category axis.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
                  "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
                  "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
                  "get_or_add_lblOffset": "Return the ``<c:lblOffset>`` child element, newly added if not present.",
                  "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
                  "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
                  "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
                  "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ChartLines": {
                "type": "class",
                "doc": "Used for `c:majorGridlines` and `c:minorGridlines`.\n\nSpecifies gridlines visual properties such as color and width.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Crosses": {
                "type": "class",
                "doc": "`c:crosses` element, specifying where the other axis crosses this one.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DateAx": {
                "type": "class",
                "doc": "`c:dateAx` element, defining a date (category) axis.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
                  "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
                  "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
                  "get_or_add_lblOffset": "Return the ``<c:lblOffset>`` child element, newly added if not present.",
                  "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
                  "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
                  "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
                  "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LblOffset": {
                "type": "class",
                "doc": "`c:lblOffset` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Orientation": {
                "type": "class",
                "doc": "`c:xAx/c:scaling/c:orientation` element, defining category order.\n\nUsed to reverse the order categories appear in on a bar chart so they start at the\ntop rather than the bottom. Because we read top-to-bottom, the default way looks odd\nto many and perhaps most folks. Also applicable to value and date axes.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Scaling": {
                "type": "class",
                "doc": "`c:scaling` element.\n\nDefines axis scale characteristics such as maximum value, log vs. linear, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_max": "Return the ``<c:max>`` child element, newly added if not present.",
                  "get_or_add_min": "Return the ``<c:min>`` child element, newly added if not present.",
                  "get_or_add_orientation": "Return the ``<c:orientation>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TextBody": {
                "type": "class",
                "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
                "methods": {
                  "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
                  "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TickLblPos": {
                "type": "class",
                "doc": "`c:tickLblPos` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TickMark": {
                "type": "class",
                "doc": "Used for `c:minorTickMark` and `c:majorTickMark`.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Title": {
                "type": "class",
                "doc": "`c:title` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
                  "get_or_add_tx_rich": "Return `c:tx/c:rich`, newly created if not present.\n\nReturn the `c:rich` grandchild at `c:tx/c:rich`. Both the `c:tx` and\n`c:rich` elements are created if not already present. Any\n`c:tx/c:strRef` element is removed. (Such an element would contain\na cell reference for the axis title text in the chart's Excel\nworksheet.)",
                  "insert_element_before": "No documentation",
                  "new_title": "Return \"loose\" `c:title` element containing default children.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ValAx": {
                "type": "class",
                "doc": "`c:valAx` element, defining a value axis.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_crossAx": "Return the ``<c:crossAx>`` child element, newly added if not present.",
                  "get_or_add_crosses": "Return the ``<c:crosses>`` child element, newly added if not present.",
                  "get_or_add_crossesAt": "Return the ``<c:crossesAt>`` child element, newly added if not present.",
                  "get_or_add_delete_": "Return the ``<c:delete>`` child element, newly added if not present.",
                  "get_or_add_majorGridlines": "Return the ``<c:majorGridlines>`` child element, newly added if not present.",
                  "get_or_add_majorTickMark": "Return the ``<c:majorTickMark>`` child element, newly added if not present.",
                  "get_or_add_majorUnit": "Return the ``<c:majorUnit>`` child element, newly added if not present.",
                  "get_or_add_minorGridlines": "Return the ``<c:minorGridlines>`` child element, newly added if not present.",
                  "get_or_add_minorTickMark": "Return the ``<c:minorTickMark>`` child element, newly added if not present.",
                  "get_or_add_minorUnit": "Return the ``<c:minorUnit>`` child element, newly added if not present.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tickLblPos": "Return the ``<c:tickLblPos>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_AxisUnit": {
                "type": "class",
                "doc": "Valid values for val attribute on c:majorUnit and others.",
                "methods": {}
              },
              "ST_LblOffset": {
                "type": "class",
                "doc": "Unsigned integer value between 0 and 1000 inclusive, with optional\npercent character ('%') suffix.",
                "methods": {}
              },
              "ST_Orientation": {
                "type": "class",
                "doc": "Valid values for `val` attribute on c:orientation (CT_Orientation).",
                "methods": {}
              },
              "XL_AXIS_CROSSES": {
                "type": "class",
                "doc": "Specifies the point on an axis where the other axis crosses.\n\nExample::\n\n    from pptx.enum.chart import XL_AXIS_CROSSES\n\n    value_axis.crosses = XL_AXIS_CROSSES.MAXIMUM\n\nMS API Name: `XlAxisCrosses`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff745402.aspx",
                "methods": {}
              },
              "XL_TICK_LABEL_POSITION": {
                "type": "class",
                "doc": "Specifies the position of tick-mark labels on a chart axis.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_LABEL_POSITION\n\n    category_axis = chart.category_axis\n    category_axis.tick_label_position = XL_TICK_LABEL_POSITION.LOW\n\nMS API Name: `XlTickLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff822561.aspx",
                "methods": {}
              },
              "XL_TICK_MARK": {
                "type": "class",
                "doc": "Specifies a type of axis tick for a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_TICK_MARK\n\n    chart.value_axis.minor_tick_mark = XL_TICK_MARK.INSIDE\n\nMS API Name: `XlTickMark`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff193878.aspx",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "chart": {
            "type": "module",
            "doc": "Custom element classes for top-level chart-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Chart": {
                "type": "class",
                "doc": "`c:chart` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_autoTitleDeleted": "Return the ``<c:autoTitleDeleted>`` child element, newly added if not present.",
                  "get_or_add_legend": "Return the ``<c:legend>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "new_chart": "Return a new `c:chart` element.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ChartSpace": {
                "type": "class",
                "doc": "`c:chartSpace` root element of a chart part.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_date1904": "Return the ``<c:date1904>`` child element, newly added if not present.",
                  "get_or_add_externalData": "Return the ``<c:externalData>`` child element, newly added if not present.",
                  "get_or_add_style": "Return the ``<c:style>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the `c:title` grandchild, newly created if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ExternalData": {
                "type": "class",
                "doc": "`<c:externalData>` element, defining link to embedded Excel package part\ncontaining the chart data.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_autoUpdate": "Return the ``<c:autoUpdate>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PlotArea": {
                "type": "class",
                "doc": "``<c:plotArea>`` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each of the `c:ser` elements in this chart, ordered first by\nthe document order of the containing xChart element, then by their\nordering within the xChart element (not necessarily document order).",
                  "iter_xCharts": "Generate each xChart child element in document.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Style": {
                "type": "class",
                "doc": "``<c:style>`` element; defines the chart style.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TextBody": {
                "type": "class",
                "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
                "methods": {
                  "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
                  "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Title": {
                "type": "class",
                "doc": "`c:title` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
                  "get_or_add_tx_rich": "Return `c:tx/c:rich`, newly created if not present.\n\nReturn the `c:rich` grandchild at `c:tx/c:rich`. Both the `c:tx` and\n`c:rich` elements are created if not already present. Any\n`c:tx/c:strRef` element is removed. (Such an element would contain\na cell reference for the axis title text in the chart's Excel\nworksheet.)",
                  "insert_element_before": "No documentation",
                  "new_title": "Return \"loose\" `c:title` element containing default children.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_Style": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdString": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrMore": {
                "type": "class",
                "doc": "Defines an optional repeating child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "datalabel": {
            "type": "module",
            "doc": "Chart data-label related oxml objects.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DLbl": {
                "type": "class",
                "doc": "``<c:dLbl>`` element specifying the properties of the data label for an\nindividual data point.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
                  "get_or_add_rich": "Return the `c:rich` descendant representing the text frame of the\ndata label, newly created if not present. Any existing `c:strRef`\nelement is removed along with its contents.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "get_or_add_tx_rich": "Return the `c:tx[c:rich]` subtree, newly created if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "remove_tx_rich": "Remove any `c:tx[c:rich]` child, or do nothing if not present.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DLblPos": {
                "type": "class",
                "doc": "``<c:dLblPos>`` element specifying the positioning of a data label with\nrespect to its data point.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DLbls": {
                "type": "class",
                "doc": "`c:dLbls` element specifying properties for a set of data labels.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_dLbl_for_point": "Return the `c:dLbl` child representing the label for the data point\nat index *idx*.",
                  "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
                  "get_or_add_dLbl_for_point": "Return the `c:dLbl` element representing the label of the point at\nindex *idx*.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_showCatName": "Return the ``<c:showCatName>`` child element, newly added if not present.",
                  "get_or_add_showLegendKey": "Return the ``<c:showLegendKey>`` child element, newly added if not present.",
                  "get_or_add_showPercent": "Return the ``<c:showPercent>`` child element, newly added if not present.",
                  "get_or_add_showSerName": "Return the ``<c:showSerName>`` child element, newly added if not present.",
                  "get_or_add_showVal": "Return the ``<c:showVal>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TextBody": {
                "type": "class",
                "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
                "methods": {
                  "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
                  "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "XL_DATA_LABEL_POSITION": {
                "type": "class",
                "doc": "Specifies where the data label is positioned.\n\nExample::\n\n    from pptx.enum.chart import XL_LABEL_POSITION\n\n    data_labels = chart.plots[0].data_labels\n    data_labels.position = XL_LABEL_POSITION.OUTSIDE_END\n\nMS API Name: `XlDataLabelPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745082.aspx",
                "methods": {}
              },
              "ZeroOrMore": {
                "type": "class",
                "doc": "Defines an optional repeating child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "legend": {
            "type": "module",
            "doc": "lxml custom element classes for legend-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Legend": {
                "type": "class",
                "doc": "``<c:legend>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_layout": "Return the ``<c:layout>`` child element, newly added if not present.",
                  "get_or_add_legendPos": "Return the ``<c:legendPos>`` child element, newly added if not present.",
                  "get_or_add_overlay": "Return the ``<c:overlay>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LegendPos": {
                "type": "class",
                "doc": "``<c:legendPos>`` element specifying position of legend with respect to\nchart as a member of ST_LegendPos.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TextBody": {
                "type": "class",
                "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
                "methods": {
                  "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
                  "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "XL_LEGEND_POSITION": {
                "type": "class",
                "doc": "Specifies the position of the legend on a chart.\n\nExample::\n\n    from pptx.enum.chart import XL_LEGEND_POSITION\n\n    chart.has_legend = True\n    chart.legend.position = XL_LEGEND_POSITION.BOTTOM\n\nMS API Name: `XlLegendPosition`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745840.aspx",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "marker": {
            "type": "module",
            "doc": "Series-related oxml objects.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Marker": {
                "type": "class",
                "doc": "`c:marker` custom element class, containing visual properties for a data\npoint marker on line-type charts.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_size": "Return the ``<c:size>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_symbol": "Return the ``<c:symbol>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_MarkerSize": {
                "type": "class",
                "doc": "`c:size` custom element class, specifying the size (in points) of a data\npoint marker for a line, XY, or radar chart.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_MarkerStyle": {
                "type": "class",
                "doc": "`c:symbol` custom element class, specifying the shape of a data point\nmarker for a line, XY, or radar chart.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_MarkerSize": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XL_MARKER_STYLE": {
                "type": "class",
                "doc": "Specifies the marker style for a point or series in a line, scatter, or radar chart.\n\nExample::\n\n    from pptx.enum.chart import XL_MARKER_STYLE\n\n    series.marker.style = XL_MARKER_STYLE.CIRCLE\n\nMS API Name: `XlMarkerStyle`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff197219.aspx",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "plot": {
            "type": "module",
            "doc": "Plot-related oxml objects.",
            "members": {
              "BaseChartElement": {
                "type": "class",
                "doc": "Base class for barChart, lineChart, and other plot elements.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Area3DChart": {
                "type": "class",
                "doc": "``<c:area3DChart>`` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_AreaChart": {
                "type": "class",
                "doc": "``<c:areaChart>`` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_BarChart": {
                "type": "class",
                "doc": "``<c:barChart>`` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_gapWidth": "Return the ``<c:gapWidth>`` child element, newly added if not present.",
                  "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
                  "get_or_add_overlap": "Return the ``<c:overlap>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_BarDir": {
                "type": "class",
                "doc": "``<c:barDir>`` child of a barChart element, specifying the orientation of\nthe bars, 'bar' if they are horizontal and 'col' if they are vertical.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_BubbleChart": {
                "type": "class",
                "doc": "``<c:bubbleChart>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_bubble3D": "Return the ``<c:bubble3D>`` child element, newly added if not present.",
                  "get_or_add_bubbleScale": "Return the ``<c:bubbleScale>`` child element, newly added if not present.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_BubbleScale": {
                "type": "class",
                "doc": "``<c:bubbleScale>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DLbls": {
                "type": "class",
                "doc": "`c:dLbls` element specifying properties for a set of data labels.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_dLbl_for_point": "Return the `c:dLbl` child representing the label for the data point\nat index *idx*.",
                  "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
                  "get_or_add_dLbl_for_point": "Return the `c:dLbl` element representing the label of the point at\nindex *idx*.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_showCatName": "Return the ``<c:showCatName>`` child element, newly added if not present.",
                  "get_or_add_showLegendKey": "Return the ``<c:showLegendKey>`` child element, newly added if not present.",
                  "get_or_add_showPercent": "Return the ``<c:showPercent>`` child element, newly added if not present.",
                  "get_or_add_showSerName": "Return the ``<c:showSerName>`` child element, newly added if not present.",
                  "get_or_add_showVal": "Return the ``<c:showVal>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DoughnutChart": {
                "type": "class",
                "doc": "``<c:doughnutChart>`` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GapAmount": {
                "type": "class",
                "doc": "``<c:gapWidth>`` child of ``<c:barChart>`` element, also used for other\npurposes like error bars.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Grouping": {
                "type": "class",
                "doc": "``<c:grouping>`` child of an xChart element, specifying a value like\n'clustered' or 'stacked'. Also used for variants with the same tag name\nlike CT_BarGrouping.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LineChart": {
                "type": "class",
                "doc": "``<c:lineChart>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_grouping": "Return the ``<c:grouping>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Overlap": {
                "type": "class",
                "doc": "``<c:overlap>`` element specifying bar overlap as an integer percentage\nof bar width, in range -100 to 100.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PieChart": {
                "type": "class",
                "doc": "``<c:pieChart>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_RadarChart": {
                "type": "class",
                "doc": "``<c:radarChart>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ScatterChart": {
                "type": "class",
                "doc": "``<c:scatterChart>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_varyColors": "Return the ``<c:varyColors>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_sers": "Generate each ``<c:ser>`` child element in this xChart in\nc:order/@val sequence (not document or c:idx order).",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_BarDir": {
                "type": "class",
                "doc": "Valid values for <c:barDir val=\"?\"> attribute",
                "methods": {}
              },
              "ST_BubbleScale": {
                "type": "class",
                "doc": "String value is an integer in range 0-300, representing a percent,\noptionally including a '%' suffix.",
                "methods": {}
              },
              "ST_GapAmount": {
                "type": "class",
                "doc": "String value is an integer in range 0-500, representing a percent,\noptionally including a '%' suffix.",
                "methods": {}
              },
              "ST_Grouping": {
                "type": "class",
                "doc": "Valid values for <c:grouping val=\"\"> attribute. Overloaded for use as\nST_BarGrouping using same tag name.",
                "methods": {}
              },
              "ST_Overlap": {
                "type": "class",
                "doc": "String value is an integer in range -100..100, representing a percent,\noptionally including a '%' suffix.",
                "methods": {}
              },
              "ZeroOrMore": {
                "type": "class",
                "doc": "Defines an optional repeating child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "series": {
            "type": "module",
            "doc": "Series-related oxml objects.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_AxDataSource": {
                "type": "class",
                "doc": "``<c:cat>`` custom element class used in category charts to specify\ncategory labels and hierarchy.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_multiLvlStrRef": "Return the ``<c:multiLvlStrRef>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DLbls": {
                "type": "class",
                "doc": "`c:dLbls` element specifying properties for a set of data labels.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_dLbl_for_point": "Return the `c:dLbl` child representing the label for the data point\nat index *idx*.",
                  "get_or_add_dLblPos": "Return the ``<c:dLblPos>`` child element, newly added if not present.",
                  "get_or_add_dLbl_for_point": "Return the `c:dLbl` element representing the label of the point at\nindex *idx*.",
                  "get_or_add_numFmt": "Return the ``<c:numFmt>`` child element, newly added if not present.",
                  "get_or_add_showCatName": "Return the ``<c:showCatName>`` child element, newly added if not present.",
                  "get_or_add_showLegendKey": "Return the ``<c:showLegendKey>`` child element, newly added if not present.",
                  "get_or_add_showPercent": "Return the ``<c:showPercent>`` child element, newly added if not present.",
                  "get_or_add_showSerName": "Return the ``<c:showSerName>`` child element, newly added if not present.",
                  "get_or_add_showVal": "Return the ``<c:showVal>`` child element, newly added if not present.",
                  "get_or_add_txPr": "Return the ``<c:txPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_DPt": {
                "type": "class",
                "doc": "``<c:dPt>`` custom element class, containing visual properties for a data\npoint.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_marker": "Return the ``<c:marker>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Lvl": {
                "type": "class",
                "doc": "``<c:lvl>`` custom element class used in multi-level categories to\nspecify a level of hierarchy.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NumDataSource": {
                "type": "class",
                "doc": "``<c:yVal>`` custom element class used in XY and bubble charts, and\nperhaps others.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "pt_v": "Return the Y value for data point *idx* in this cache, or None if no\nvalue is present for that data point.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_SeriesComposite": {
                "type": "class",
                "doc": "``<c:ser>`` custom element class. Note there are several different series\nelement types in the schema, such as ``CT_LineSer`` and ``CT_BarSer``,\nbut they all share the same tag name. This class acts as a composite and\ndepends on the caller not to do anything invalid for a series belonging\nto a particular plot type.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_dLbl": "Return the `c:dLbl` element representing the label for the data point\nat offset *idx* in this series, or |None| if not present.",
                  "get_or_add_bubbleSize": "Return the ``<c:bubbleSize>`` child element, newly added if not present.",
                  "get_or_add_cat": "Return the ``<c:cat>`` child element, newly added if not present.",
                  "get_or_add_dLbl": "Return the `c:dLbl` element representing the label of the point at\noffset *idx* in this series, newly created if not yet present.",
                  "get_or_add_dLbls": "Return the ``<c:dLbls>`` child element, newly added if not present.",
                  "get_or_add_dPt_for_point": "Return the `c:dPt` child representing the visual properties of the\ndata point at index *idx*.",
                  "get_or_add_invertIfNegative": "Return the ``<c:invertIfNegative>`` child element, newly added if not present.",
                  "get_or_add_marker": "Return the ``<c:marker>`` child element, newly added if not present.",
                  "get_or_add_smooth": "Return the ``<c:smooth>`` child element, newly added if not present.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
                  "get_or_add_val": "Return the ``<c:val>`` child element, newly added if not present.",
                  "get_or_add_xVal": "Return the ``<c:xVal>`` child element, newly added if not present.",
                  "get_or_add_yVal": "Return the ``<c:yVal>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_StrVal_NumVal_Composite": {
                "type": "class",
                "doc": "``<c:pt>`` element, can be either CT_StrVal or CT_NumVal complex type.\nUsing this class for both, differentiating as needed.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "XsdUnsignedInt": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrMore": {
                "type": "class",
                "doc": "Defines an optional repeating child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "shared": {
            "type": "module",
            "doc": "Shared oxml objects for charts.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Boolean": {
                "type": "class",
                "doc": "Common complex type used for elements having a True/False value.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Boolean_Explicit": {
                "type": "class",
                "doc": "Always spells out the `val` attribute, e.g. `val=1`.\n\nAt least one boolean element is improperly interpreted by one or more\nversions of PowerPoint. The `c:overlay` element is interpreted as |False|\nwhen no `val` attribute is present, contrary to the behavior described in\nthe schema. A remedy for this is to interpret a missing `val` attribute\nas |True| (consistent with the spec), but always write the attribute\nwhenever there is occasion for changing the element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Double": {
                "type": "class",
                "doc": "Used for floating point values.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Layout": {
                "type": "class",
                "doc": "``<c:layout>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_manualLayout": "Return the ``<c:manualLayout>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LayoutMode": {
                "type": "class",
                "doc": "Used for ``<c:xMode>``, ``<c:yMode>``, ``<c:wMode>``, and ``<c:hMode>``\nchild elements of CT_ManualLayout.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ManualLayout": {
                "type": "class",
                "doc": "``<c:manualLayout>`` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_x": "Return the ``<c:x>`` child element, newly added if not present.",
                  "get_or_add_xMode": "Return the ``<c:xMode>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NumFmt": {
                "type": "class",
                "doc": "``<c:numFmt>`` element specifying the formatting for number labels on a\ntick mark or data point.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Title": {
                "type": "class",
                "doc": "`c:title` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_spPr": "Return the ``<c:spPr>`` child element, newly added if not present.",
                  "get_or_add_tx": "Return the ``<c:tx>`` child element, newly added if not present.",
                  "get_or_add_tx_rich": "Return `c:tx/c:rich`, newly created if not present.\n\nReturn the `c:rich` grandchild at `c:tx/c:rich`. Both the `c:tx` and\n`c:rich` elements are created if not already present. Any\n`c:tx/c:strRef` element is removed. (Such an element would contain\na cell reference for the axis title text in the chart's Excel\nworksheet.)",
                  "insert_element_before": "No documentation",
                  "new_title": "Return \"loose\" `c:title` element containing default children.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Tx": {
                "type": "class",
                "doc": "``<c:tx>`` element containing the text for a label on a data point or\nother chart item.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_rich": "Return the ``<c:rich>`` child element, newly added if not present.",
                  "get_or_add_strRef": "Return the ``<c:strRef>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_UnsignedInt": {
                "type": "class",
                "doc": "``<c:idx>`` element and others.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_LayoutMode": {
                "type": "class",
                "doc": "Valid values for `val` attribute on c:xMode and other elements of type\nCT_LayoutMode.",
                "methods": {}
              },
              "XsdBoolean": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdDouble": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdString": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdUnsignedInt": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          }
        }
      },
      "coreprops": {
        "type": "module",
        "doc": "lxml custom element classes for core properties-related XML elements.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_CoreProperties": {
            "type": "class",
            "doc": "`cp:coreProperties` element.\n\nThe root element of the Core Properties part stored as `/docProps/core.xml`. Implements many\nof the Dublin Core document metadata elements. String elements resolve to an empty string ('')\nif the element is not present in the XML. String elements are limited in length to 255 unicode\ncharacters.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_category": "Return the ``<cp:category>`` child element, newly added if not present.",
              "get_or_add_contentStatus": "Return the ``<cp:contentStatus>`` child element, newly added if not present.",
              "get_or_add_created": "Return the ``<dcterms:created>`` child element, newly added if not present.",
              "get_or_add_creator": "Return the ``<dc:creator>`` child element, newly added if not present.",
              "get_or_add_description": "Return the ``<dc:description>`` child element, newly added if not present.",
              "get_or_add_identifier": "Return the ``<dc:identifier>`` child element, newly added if not present.",
              "get_or_add_keywords": "Return the ``<cp:keywords>`` child element, newly added if not present.",
              "get_or_add_language": "Return the ``<dc:language>`` child element, newly added if not present.",
              "get_or_add_lastModifiedBy": "Return the ``<cp:lastModifiedBy>`` child element, newly added if not present.",
              "get_or_add_lastPrinted": "Return the ``<cp:lastPrinted>`` child element, newly added if not present.",
              "get_or_add_modified": "Return the ``<dcterms:modified>`` child element, newly added if not present.",
              "get_or_add_revision": "Return the ``<cp:revision>`` child element, newly added if not present.",
              "get_or_add_subject": "Return the ``<dc:subject>`` child element, newly added if not present.",
              "get_or_add_title": "Return the ``<dc:title>`` child element, newly added if not present.",
              "get_or_add_version": "Return the ``<cp:version>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "new_coreProperties": "Return a new `cp:coreProperties` element",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          }
        }
      },
      "dml": {
        "type": "module",
        "doc": "No documentation",
        "members": {
          "color": {
            "type": "module",
            "doc": "lxml custom element classes for DrawingML-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Color": {
                "type": "class",
                "doc": "Custom element class for `a:fgClr`, `a:bgClr` and perhaps others.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_HslColor": {
                "type": "class",
                "doc": "Custom element class for <a:hslClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Percentage": {
                "type": "class",
                "doc": "Custom element class for <a:lumMod> and <a:lumOff> elements.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PresetColor": {
                "type": "class",
                "doc": "Custom element class for <a:prstClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_SRgbColor": {
                "type": "class",
                "doc": "Custom element class for <a:srgbClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ScRgbColor": {
                "type": "class",
                "doc": "Custom element class for <a:scrgbClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_SchemeColor": {
                "type": "class",
                "doc": "Custom element class for <a:schemeClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_SystemColor": {
                "type": "class",
                "doc": "Custom element class for <a:sysClr> element.",
                "methods": {
                  "add_lumMod": "Return a newly added <a:lumMod> child element.",
                  "add_lumOff": "Return a newly added <a:lumOff> child element.",
                  "clear_lum": "Return self after removing any <a:lumMod> and <a:lumOff> child\nelements.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_lumMod": "Return the ``<a:lumMod>`` child element, newly added if not present.",
                  "get_or_add_lumOff": "Return the ``<a:lumOff>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "Choice": {
                "type": "class",
                "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "MSO_THEME_COLOR": {
                "type": "class",
                "doc": "An Office theme color, one of those shown in the color gallery on the formatting ribbon.\n\nAlias: ``MSO_THEME_COLOR``\n\nExample::\n\n    from pptx.enum.dml import MSO_THEME_COLOR\n\n    shape.fill.solid()\n    shape.fill.fore_color.theme_color = MSO_THEME_COLOR.ACCENT_1\n\nMS API Name: `MsoThemeColorIndex`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860782(v=office.15).aspx",
                "methods": {}
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_HexColorRGB": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ST_Percentage": {
                "type": "class",
                "doc": "Percentage value like 42000 or '42.0%'\n\nEither an integer literal representing 1000ths of a percent\n(e.g. \"42000\"), or a floating point literal with a '%' suffix\n(e.g. \"42.0%).",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "ZeroOrOneChoice": {
                "type": "class",
                "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "fill": {
            "type": "module",
            "doc": "lxml custom element classes for DrawingML-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Blip": {
                "type": "class",
                "doc": "<a:blip> element",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_BlipFillProperties": {
                "type": "class",
                "doc": "Custom element class for <a:blipFill> element.",
                "methods": {
                  "crop": "Set `a:srcRect` child to crop according to *cropping* values.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_blip": "Return the ``<a:blip>`` child element, newly added if not present.",
                  "get_or_add_srcRect": "Return the ``<a:srcRect>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GradientFillProperties": {
                "type": "class",
                "doc": "`a:gradFill` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
                  "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
                  "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GradientStop": {
                "type": "class",
                "doc": "`a:gs` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GradientStopList": {
                "type": "class",
                "doc": "`a:gsLst` custom element class.",
                "methods": {
                  "add_gs": "Add a new ``<a:gs>`` child element unconditionally, inserted in the correct sequence.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GroupFillProperties": {
                "type": "class",
                "doc": "`a:grpFill` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LinearShadeProperties": {
                "type": "class",
                "doc": "`a:lin` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NoFillProperties": {
                "type": "class",
                "doc": "`a:noFill` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PatternFillProperties": {
                "type": "class",
                "doc": "`a:pattFill` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_bgClr": "Return the ``<a:bgClr>`` child element, newly added if not present.",
                  "get_or_add_fgClr": "Return the ``<a:fgClr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_RelativeRect": {
                "type": "class",
                "doc": "`a:srcRect` element and perhaps others.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_SolidColorFillProperties": {
                "type": "class",
                "doc": "`a:solidFill` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_change_to_hslClr": "Return the ``<a:hslClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_prstClr": "Return the ``<a:prstClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_schemeClr": "Return the ``<a:schemeClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_scrgbClr": "Return the ``<a:scrgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_srgbClr": "Return the ``<a:srgbClr>`` child, replacing any other group element if found.",
                  "get_or_change_to_sysClr": "Return the ``<a:sysClr>`` child, replacing any other group element if found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "Choice": {
                "type": "class",
                "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "MSO_PATTERN_TYPE": {
                "type": "class",
                "doc": "Specifies the fill pattern used in a shape.\n\nAlias: ``MSO_PATTERN``\n\nExample::\n\n    from pptx.enum.dml import MSO_PATTERN\n\n    fill = shape.fill\n    fill.patterned()\n    fill.pattern = MSO_PATTERN.WAVE\n\nMS API Name: `MsoPatternType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoPatternType",
                "methods": {}
              },
              "OneOrMore": {
                "type": "class",
                "doc": "Defines a repeating child element for MetaOxmlElement that must appear at least once.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_Percentage": {
                "type": "class",
                "doc": "Percentage value like 42000 or '42.0%'\n\nEither an integer literal representing 1000ths of a percent\n(e.g. \"42000\"), or a floating point literal with a '%' suffix\n(e.g. \"42.0%).",
                "methods": {}
              },
              "ST_PositiveFixedAngle": {
                "type": "class",
                "doc": "Valid values for `a:lin@ang`.\n\n60000ths of a degree rotation, constained to positive angles less than\n360 degrees.",
                "methods": {}
              },
              "ST_PositiveFixedPercentage": {
                "type": "class",
                "doc": "Percentage value between 0 and 100% like 42000 or '42.0%'\n\nEither an integer literal representing 1000ths of a percent\n(e.g. \"42000\"), or a floating point literal with a '%' suffix\n(e.g. \"42.0%). Value is constrained to range of 0% to 100%. The source\nvalue is a float between 0.0 and 1.0.",
                "methods": {}
              },
              "ST_RelationshipId": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "ZeroOrOneChoice": {
                "type": "class",
                "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "line": {
            "type": "module",
            "doc": "lxml custom element classes for DrawingML line-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PresetLineDashProperties": {
                "type": "class",
                "doc": "`a:prstDash` custom element class",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "MSO_LINE_DASH_STYLE": {
                "type": "class",
                "doc": "Specifies the dash style for a line.\n\nAlias: ``MSO_LINE``\n\nExample::\n\n    from pptx.enum.dml import MSO_LINE\n\n    shape.line.dash_style = MSO_LINE.DASH_DOT_DOT\n\nMS API name: `MsoLineDashStyle`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoLineDashStyle",
                "methods": {}
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              }
            }
          }
        }
      },
      "ns": {
        "type": "module",
        "doc": "Namespace related objects.",
        "members": {
          "NamespacePrefixedTag": {
            "type": "class",
            "doc": "Value object that knows the semantics of an XML tag having a namespace prefix.",
            "methods": {}
          }
        }
      },
      "presentation": {
        "type": "module",
        "doc": "Custom element classes for presentation-related XML elements.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Presentation": {
            "type": "class",
            "doc": "`p:presentation` element, root of the Presentation part stored as `/ppt/presentation.xml`.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_sldIdLst": "Return the ``<p:sldIdLst>`` child element, newly added if not present.",
              "get_or_add_sldMasterIdLst": "Return the ``<p:sldMasterIdLst>`` child element, newly added if not present.",
              "get_or_add_sldSz": "Return the ``<p:sldSz>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideId": {
            "type": "class",
            "doc": "`p:sldId` element.\n\nDirect child of `p:sldIdLst` that contains an `rId` reference to a slide in the presentation.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideIdList": {
            "type": "class",
            "doc": "`p:sldIdLst` element.\n\nDirect child of <p:presentation> that contains a list of the slide parts in the presentation.",
            "methods": {
              "add_sldId": "Create and return a reference to a new `p:sldId` child element.\n\nThe new `p:sldId` element has its r:id attribute set to `rId`.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideMasterIdList": {
            "type": "class",
            "doc": "`p:sldMasterIdLst` element.\n\nChild of `p:presentation` containing references to the slide masters that belong to the\npresentation.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideMasterIdListEntry": {
            "type": "class",
            "doc": "``<p:sldMasterId>`` element, child of ``<p:sldMasterIdLst>`` containing\na reference to a slide master.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideSize": {
            "type": "class",
            "doc": "`p:sldSz` element.\n\nDirect child of <p:presentation> that contains the width and height of slides in the\npresentation.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ST_SlideId": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_SlideSizeCoordinate": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          }
        }
      },
      "shapes": {
        "type": "module",
        "doc": "Base shape-related objects such as BaseShape.",
        "members": {
          "autoshape": {
            "type": "module",
            "doc": "lxml custom element classes for shape-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_AdjPoint2D": {
                "type": "class",
                "doc": "`a:pt` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_CustomGeometry2D": {
                "type": "class",
                "doc": "`a:custGeom` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_pathLst": "Return the ``<a:pathLst>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GeomGuide": {
                "type": "class",
                "doc": "`a:gd` custom element class.\n\nDefines a \"guide\", corresponding to a yellow diamond-shaped handle on an autoshape.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GeomGuideList": {
                "type": "class",
                "doc": "`a:avLst` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NonVisualDrawingShapeProps": {
                "type": "class",
                "doc": "`p:cNvSpPr` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_spLocks": "Return the ``<a:spLocks>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Path2D": {
                "type": "class",
                "doc": "`a:path` custom element class.",
                "methods": {
                  "add_close": "Return a newly created `a:close` element.\n\nThe new `a:close` element is appended to this `a:path` element.",
                  "add_lnTo": "Return a newly created `a:lnTo` subtree with end point *(x, y)*.\n\nThe new `a:lnTo` element is appended to this `a:path` element.",
                  "add_moveTo": "Return a newly created `a:moveTo` subtree with point `(x, y)`.\n\nThe new `a:moveTo` element is appended to this `a:path` element.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Path2DClose": {
                "type": "class",
                "doc": "`a:close` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Path2DLineTo": {
                "type": "class",
                "doc": "`a:lnTo` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_pt": "Return the ``<a:pt>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Path2DList": {
                "type": "class",
                "doc": "`a:pathLst` custom element class.",
                "methods": {
                  "add_path": "Return a newly created `a:path` child element.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Path2DMoveTo": {
                "type": "class",
                "doc": "`a:moveTo` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_pt": "Return the ``<a:pt>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PresetGeometry2D": {
                "type": "class",
                "doc": "`a:prstGeom` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_avLst": "Return the ``<a:avLst>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "rewrite_guides": "Replace any `a:gd` element children of `a:avLst` with ones forme from `guides`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Shape": {
                "type": "class",
                "doc": "`p:sp` custom element class.",
                "methods": {
                  "add_path": "No documentation",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_ln": "Return the `a:ln` grandchild element, newly added if not present.",
                  "get_or_add_txBody": "Return the ``<p:txBody>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "new_autoshape_sp": "Return a new `p:sp` element tree configured as a base auto shape.",
                  "new_freeform_sp": "Return new `p:sp` element tree configured as freeform shape.\n\nThe returned shape has a `a:custGeom` subtree but no paths in its\npath list.",
                  "new_placeholder_sp": "Return a new `p:sp` element tree configured as a placeholder shape.",
                  "new_textbox_sp": "Return a new `p:sp` element tree configured as a base textbox shape.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ShapeNonVisual": {
                "type": "class",
                "doc": "`p:nvSpPr` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_TextBody": {
                "type": "class",
                "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
                "methods": {
                  "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
                  "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "MSO_AUTO_SHAPE_TYPE": {
                "type": "class",
                "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
                "methods": {}
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "PP_PLACEHOLDER": {
                "type": "class",
                "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
                "methods": {}
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_Coordinate": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ST_PositiveCoordinate": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdBoolean": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdString": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrMore": {
                "type": "class",
                "doc": "Defines an optional repeating child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "connector": {
            "type": "module",
            "doc": "lxml custom element classes for XML elements related to the Connector shape.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Connection": {
                "type": "class",
                "doc": "A `a:stCxn` or `a:endCxn` element.\n\nSpecifies a connection between an end-point of a connector and a shape connection point.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Connector": {
                "type": "class",
                "doc": "A line/connector shape `p:cxnSp` element",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ConnectorNonVisual": {
                "type": "class",
                "doc": "`p:nvCxnSpPr` element, container for the non-visual properties of\na connector, such as name, id, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NonVisualConnectorProperties": {
                "type": "class",
                "doc": "`p:cNvCxnSpPr` element, container for the non-visual properties specific\nto a connector shape, such as connections and connector locking.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_endCxn": "Return the ``<a:endCxn>`` child element, newly added if not present.",
                  "get_or_add_stCxn": "Return the ``<a:stCxn>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_DrawingElementId": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdUnsignedInt": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "graphfrm": {
            "type": "module",
            "doc": "lxml custom element class for CT_GraphicalObjectFrame XML element.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Chart": {
                "type": "class",
                "doc": "`c:chart` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_autoTitleDeleted": "Return the ``<c:autoTitleDeleted>`` child element, newly added if not present.",
                  "get_or_add_legend": "Return the ``<c:legend>`` child element, newly added if not present.",
                  "get_or_add_title": "Return the ``<c:title>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "new_chart": "Return a new `c:chart` element.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GraphicalObject": {
                "type": "class",
                "doc": "`a:graphic` element.\n\nThe container for the reference to or definition of the framed graphical object (table, chart,\netc.).",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GraphicalObjectData": {
                "type": "class",
                "doc": "`p:graphicData` element.\n\nThe direct container for a table, a chart, or another graphical object.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_chart": "Return the ``<c:chart>`` child element, newly added if not present.",
                  "get_or_add_tbl": "Return the ``<a:tbl>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GraphicalObjectFrame": {
                "type": "class",
                "doc": "`p:graphicFrame` element.\n\nA container for a table, a chart, or another graphical object.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the required `p:xfrm` child element.\n\nOverrides version on BaseShapeElement.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GraphicalObjectFrameNonVisual": {
                "type": "class",
                "doc": "`p:nvGraphicFramePr` element.\n\nThis contains the non-visual properties of a graphic frame, such as name, id, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_OleObject": {
                "type": "class",
                "doc": "`p:oleObj` element, container for an OLE object (e.g. Excel file).\n\nAn OLE object can be either linked or embedded (hence the name).",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Table": {
                "type": "class",
                "doc": "`a:tbl` custom element class",
                "methods": {
                  "add_tr": "Return a newly created `a:tr` child element having its `h` attribute set to `height`.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_tblPr": "Return the ``<a:tblPr>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_tcs": "Generate each `a:tc` element in this tbl.\n\n`a:tc` elements are generated left-to-right, top-to-bottom.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "tc": "Return `a:tc` element at `row_idx`, `col_idx`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "XsdBoolean": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdString": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "groupshape": {
            "type": "module",
            "doc": "lxml custom element classes for shape-tree-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Connector": {
                "type": "class",
                "doc": "A line/connector shape `p:cxnSp` element",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GraphicalObjectFrame": {
                "type": "class",
                "doc": "`p:graphicFrame` element.\n\nA container for a table, a chart, or another graphical object.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the required `p:xfrm` child element.\n\nOverrides version on BaseShapeElement.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GroupShape": {
                "type": "class",
                "doc": "Used for shape tree (`p:spTree`) as well as the group shape (`p:grpSp`) elements.",
                "methods": {
                  "add_autoshape": "Return new `p:sp` appended to the group/shapetree with specified attributes.",
                  "add_cxnSp": "Return new `p:cxnSp` appended to the group/shapetree with the specified attribues.",
                  "add_freeform_sp": "Append a new freeform `p:sp` with specified position and size.",
                  "add_grpSp": "Return `p:grpSp` element newly appended to this shape tree.\n\nThe element contains no sub-shapes, is positioned at (0, 0), and has\nwidth and height of zero.",
                  "add_pic": "Append a `p:pic` shape to the group/shapetree having properties as specified in call.",
                  "add_placeholder": "Append a newly-created placeholder `p:sp` shape having the specified properties.",
                  "add_table": "Append a `p:graphicFrame` shape containing a table as specified in call.",
                  "add_textbox": "Append a newly-created textbox `p:sp` shape having the specified position and size.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.",
                  "insert_element_before": "No documentation",
                  "iter_ph_elms": "Generate each placeholder shape child element in document order.",
                  "iter_shape_elms": "Generate each child of this `p:spTree` element that corresponds to a shape.\n\nItems appear in XML document order.",
                  "recalculate_extents": "Adjust x, y, cx, and cy to incorporate all contained shapes.\n\nThis would typically be called when a contained shape is added,\nremoved, or its position or size updated.\n\nThis method is recursive \"upwards\" since a change in a group shape\ncan change the position and size of its containing group.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GroupShapeNonVisual": {
                "type": "class",
                "doc": "`p:nvGrpSpPr` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GroupShapeProperties": {
                "type": "class",
                "doc": "p:grpSpPr element",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_effectLst": "Return the ``<a:effectLst>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the ``<a:xfrm>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Picture": {
                "type": "class",
                "doc": "`p:pic` element.\n\nRepresents a picture shape (an image placement on a slide).",
                "methods": {
                  "crop_to_fit": "Set cropping values in `p:blipFill/a:srcRect` such that an image of\n*image_size* will stretch to exactly fit *view_size* when its aspect\nratio is preserved.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_ln": "Return the <a:ln> grandchild element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Shape": {
                "type": "class",
                "doc": "`p:sp` custom element class.",
                "methods": {
                  "add_path": "No documentation",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_ln": "Return the `a:ln` grandchild element, newly added if not present.",
                  "get_or_add_txBody": "Return the ``<p:txBody>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "new_autoshape_sp": "Return a new `p:sp` element tree configured as a base auto shape.",
                  "new_freeform_sp": "Return new `p:sp` element tree configured as freeform shape.\n\nThe returned shape has a `a:custGeom` subtree but no paths in its\npath list.",
                  "new_placeholder_sp": "Return a new `p:sp` element tree configured as a placeholder shape.",
                  "new_textbox_sp": "Return a new `p:sp` element tree configured as a base textbox shape.",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "Emu": {
                "type": "class",
                "doc": "Convenience constructor for length in english metric units.",
                "methods": {}
              },
              "MSO_CONNECTOR_TYPE": {
                "type": "class",
                "doc": "Specifies a type of connector.\n\nAlias: ``MSO_CONNECTOR``\n\nExample::\n\n    from pptx.enum.shapes import MSO_CONNECTOR\n    from pptx.util import Cm\n\n    shapes = prs.slides[0].shapes\n    connector = shapes.add_connector(\n        MSO_CONNECTOR.STRAIGHT, Cm(2), Cm(2), Cm(10), Cm(10)\n    )\n    assert connector.left.cm == 2\n\nMS API Name: `MsoConnectorType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860918.aspx",
                "methods": {}
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          },
          "picture": {
            "type": "module",
            "doc": "lxml custom element classes for picture-related XML elements.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Picture": {
                "type": "class",
                "doc": "`p:pic` element.\n\nRepresents a picture shape (an image placement on a slide).",
                "methods": {
                  "crop_to_fit": "Set cropping values in `p:blipFill/a:srcRect` such that an image of\n*image_size* will stretch to exactly fit *view_size* when its aspect\nratio is preserved.",
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_ln": "Return the <a:ln> grandchild element, newly added if not present.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PictureNonVisual": {
                "type": "class",
                "doc": "``<p:nvPicPr>`` element, containing non-visual properties for a picture\nshape.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "OneAndOnlyOne": {
                "type": "class",
                "doc": "Defines a required child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              }
            }
          },
          "shared": {
            "type": "module",
            "doc": "Common shape-related oxml objects.",
            "members": {
              "BaseOxmlElement": {
                "type": "class",
                "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "BaseShapeElement": {
                "type": "class",
                "doc": "Provides common behavior for shape element classes like CT_Shape, CT_Picture, etc.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ApplicationNonVisualDrawingProps": {
                "type": "class",
                "doc": "`p:nvPr` element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_ph": "Return the ``<p:ph>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_GradientFillProperties": {
                "type": "class",
                "doc": "`a:gradFill` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
                  "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
                  "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_LineProperties": {
                "type": "class",
                "doc": "Custom element class for <a:ln> element",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_custDash": "Return the ``<a:custDash>`` child element, newly added if not present.",
                  "get_or_add_prstDash": "Return the ``<a:prstDash>`` child element, newly added if not present.",
                  "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_NonVisualDrawingProps": {
                "type": "class",
                "doc": "`p:cNvPr` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_hlinkClick": "Return the ``<a:hlinkClick>`` child element, newly added if not present.",
                  "get_or_add_hlinkHover": "Return the ``<a:hlinkHover>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Placeholder": {
                "type": "class",
                "doc": "`p:ph` custom element class.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Point2D": {
                "type": "class",
                "doc": "Custom element class for <a:off> element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_PositiveSize2D": {
                "type": "class",
                "doc": "Custom element class for <a:ext> element.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_ShapeProperties": {
                "type": "class",
                "doc": "Custom element class for `p:spPr` element.\n\nShared by `p:sp`, `p:cxnSp`,  and `p:pic` elements as well as a few more obscure ones.",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_custGeom": "Return the ``<a:custGeom>`` child element, newly added if not present.",
                  "get_or_add_effectLst": "Return the ``<a:effectLst>`` child element, newly added if not present.",
                  "get_or_add_ln": "Return the ``<a:ln>`` child element, newly added if not present.",
                  "get_or_add_prstGeom": "Return the ``<a:prstGeom>`` child element, newly added if not present.",
                  "get_or_add_xfrm": "Return the ``<a:xfrm>`` child element, newly added if not present.",
                  "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
                  "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "CT_Transform2D": {
                "type": "class",
                "doc": "`a:xfrm` custom element class.\n\nNOTE: this is a composite including CT_GroupTransform2D, which appears\nwith the `a:xfrm` tag in a group shape (including a slide `p:spTree`).",
                "methods": {
                  "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
                  "get_or_add_chExt": "Return the ``<a:chExt>`` child element, newly added if not present.",
                  "get_or_add_chOff": "Return the ``<a:chOff>`` child element, newly added if not present.",
                  "get_or_add_ext": "Return the ``<a:ext>`` child element, newly added if not present.",
                  "get_or_add_off": "Return the ``<a:off>`` child element, newly added if not present.",
                  "insert_element_before": "No documentation",
                  "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
                  "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
                }
              },
              "Choice": {
                "type": "class",
                "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "Emu": {
                "type": "class",
                "doc": "Convenience constructor for length in english metric units.",
                "methods": {}
              },
              "OptionalAttribute": {
                "type": "class",
                "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "PP_PLACEHOLDER": {
                "type": "class",
                "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
                "methods": {}
              },
              "RequiredAttribute": {
                "type": "class",
                "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to *element_cls*."
                }
              },
              "ST_Angle": {
                "type": "class",
                "doc": "Valid values for `rot` attribute on `<a:xfrm>` element. 60000ths of\na degree rotation.",
                "methods": {}
              },
              "ST_Coordinate": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ST_Direction": {
                "type": "class",
                "doc": "Valid values for `<p:ph orient=\"...\">` attribute.",
                "methods": {}
              },
              "ST_DrawingElementId": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ST_LineWidth": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ST_PlaceholderSize": {
                "type": "class",
                "doc": "Valid values for <p:ph> sz (size) attribute",
                "methods": {}
              },
              "ST_PositiveCoordinate": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdBoolean": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdString": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "XsdUnsignedInt": {
                "type": "class",
                "doc": "No documentation",
                "methods": {}
              },
              "ZeroOrOne": {
                "type": "class",
                "doc": "Defines an optional child element for MetaOxmlElement.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              },
              "ZeroOrOneChoice": {
                "type": "class",
                "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
                "methods": {
                  "populate_class_members": "Add the appropriate methods to `element_cls`."
                }
              }
            }
          }
        }
      },
      "simpletypes": {
        "type": "module",
        "doc": "Simple-type classes.\n\nA \"simple-type\" is a scalar type, generally serving as an XML attribute. This is in contrast to a\n\"complex-type\" which would specify an XML element.\n\nThese objects providing validation and format translation for values stored in XML element\nattributes. Naming generally corresponds to the simple type in the associated XML schema.",
        "members": {
          "BaseFloatType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "BaseIntType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "BaseSimpleType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "BaseStringEnumerationType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "BaseStringType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "Centipoints": {
            "type": "class",
            "doc": "Convenience constructor for length in hundredths of a point.",
            "methods": {}
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "InvalidXmlError": {
            "type": "class",
            "doc": "Raised when a value is encountered in the XML that is not valid according\nto the schema.",
            "methods": {}
          },
          "ST_Angle": {
            "type": "class",
            "doc": "Valid values for `rot` attribute on `<a:xfrm>` element. 60000ths of\na degree rotation.",
            "methods": {}
          },
          "ST_AxisUnit": {
            "type": "class",
            "doc": "Valid values for val attribute on c:majorUnit and others.",
            "methods": {}
          },
          "ST_BarDir": {
            "type": "class",
            "doc": "Valid values for <c:barDir val=\"?\"> attribute",
            "methods": {}
          },
          "ST_BubbleScale": {
            "type": "class",
            "doc": "String value is an integer in range 0-300, representing a percent,\noptionally including a '%' suffix.",
            "methods": {}
          },
          "ST_ContentType": {
            "type": "class",
            "doc": "Has a pretty wicked regular expression it needs to match in the schema,\nbut figuring it's not worth the trouble or run time to identify\na programming error (as opposed to a user/runtime error).",
            "methods": {}
          },
          "ST_Coordinate": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Coordinate32": {
            "type": "class",
            "doc": "xsd:union of ST_Coordinate32Unqualified, ST_UniversalMeasure",
            "methods": {}
          },
          "ST_Coordinate32Unqualified": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_CoordinateUnqualified": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Direction": {
            "type": "class",
            "doc": "Valid values for `<p:ph orient=\"...\">` attribute.",
            "methods": {}
          },
          "ST_DrawingElementId": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Extension": {
            "type": "class",
            "doc": "Has a regular expression it needs to match in the schema, but figuring\nit's not worth the trouble or run time to identify a programming error\n(as opposed to a user/runtime error).",
            "methods": {}
          },
          "ST_GapAmount": {
            "type": "class",
            "doc": "String value is an integer in range 0-500, representing a percent,\noptionally including a '%' suffix.",
            "methods": {}
          },
          "ST_Grouping": {
            "type": "class",
            "doc": "Valid values for <c:grouping val=\"\"> attribute. Overloaded for use as\nST_BarGrouping using same tag name.",
            "methods": {}
          },
          "ST_HexColorRGB": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_LayoutMode": {
            "type": "class",
            "doc": "Valid values for `val` attribute on c:xMode and other elements of type\nCT_LayoutMode.",
            "methods": {}
          },
          "ST_LblOffset": {
            "type": "class",
            "doc": "Unsigned integer value between 0 and 1000 inclusive, with optional\npercent character ('%') suffix.",
            "methods": {}
          },
          "ST_LineWidth": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_MarkerSize": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Orientation": {
            "type": "class",
            "doc": "Valid values for `val` attribute on c:orientation (CT_Orientation).",
            "methods": {}
          },
          "ST_Overlap": {
            "type": "class",
            "doc": "String value is an integer in range -100..100, representing a percent,\noptionally including a '%' suffix.",
            "methods": {}
          },
          "ST_Percentage": {
            "type": "class",
            "doc": "Percentage value like 42000 or '42.0%'\n\nEither an integer literal representing 1000ths of a percent\n(e.g. \"42000\"), or a floating point literal with a '%' suffix\n(e.g. \"42.0%).",
            "methods": {}
          },
          "ST_PlaceholderSize": {
            "type": "class",
            "doc": "Valid values for <p:ph> sz (size) attribute",
            "methods": {}
          },
          "ST_PositiveCoordinate": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_PositiveFixedAngle": {
            "type": "class",
            "doc": "Valid values for `a:lin@ang`.\n\n60000ths of a degree rotation, constained to positive angles less than\n360 degrees.",
            "methods": {}
          },
          "ST_PositiveFixedPercentage": {
            "type": "class",
            "doc": "Percentage value between 0 and 100% like 42000 or '42.0%'\n\nEither an integer literal representing 1000ths of a percent\n(e.g. \"42000\"), or a floating point literal with a '%' suffix\n(e.g. \"42.0%). Value is constrained to range of 0% to 100%. The source\nvalue is a float between 0.0 and 1.0.",
            "methods": {}
          },
          "ST_RelationshipId": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_SlideId": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_SlideSizeCoordinate": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Style": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TargetMode": {
            "type": "class",
            "doc": "The valid values for the ``TargetMode`` attribute in a Relationship\nelement, either 'External' or 'Internal'.",
            "methods": {}
          },
          "ST_TextFontScalePercentOrPercentString": {
            "type": "class",
            "doc": "Valid values for the `fontScale` attribute of ``<a:normAutofit>``.\nTranslates to a float value.",
            "methods": {}
          },
          "ST_TextFontSize": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextIndentLevelType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextSpacingPercentOrPercentString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextSpacingPoint": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextTypeface": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextWrappingType": {
            "type": "class",
            "doc": "Valid values for <a:bodyPr wrap=\"\"> attribute",
            "methods": {}
          },
          "ST_UniversalMeasure": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdAnyUri": {
            "type": "class",
            "doc": "There's a regular expression this is supposed to meet but so far thinking\nspending cycles on validating wouldn't be worth it for the number of\nprogramming errors it would catch.",
            "methods": {}
          },
          "XsdBoolean": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdDouble": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdId": {
            "type": "class",
            "doc": "String that must begin with a letter or underscore and cannot contain any\ncolons. Not fully validated because not used in external API.",
            "methods": {}
          },
          "XsdInt": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdLong": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdStringEnumeration": {
            "type": "class",
            "doc": "Set of enumerated xsd:string values.",
            "methods": {}
          },
          "XsdToken": {
            "type": "class",
            "doc": "xsd:string with whitespace collapsing, e.g. multiple spaces reduced to\none, leading and trailing space stripped.",
            "methods": {}
          },
          "XsdTokenEnumeration": {
            "type": "class",
            "doc": "xsd:string with whitespace collapsing, e.g. multiple spaces reduced to\none, leading and trailing space stripped.",
            "methods": {}
          },
          "XsdUnsignedByte": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdUnsignedInt": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdUnsignedShort": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          }
        }
      },
      "slide": {
        "type": "module",
        "doc": "Slide-related custom element classes, including those for masters.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Background": {
            "type": "class",
            "doc": "`p:bg` element.",
            "methods": {
              "add_noFill_bgPr": "Return a new `p:bgPr` element with noFill properties.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_bgPr": "Return the ``<p:bgPr>`` child element, newly added if not present.",
              "get_or_add_bgRef": "Return the ``<p:bgRef>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_BackgroundProperties": {
            "type": "class",
            "doc": "`p:bgPr` element.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
              "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
              "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
              "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
              "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
              "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_CommonSlideData": {
            "type": "class",
            "doc": "`p:cSld` element.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_bg": "Return the ``<p:bg>`` child element, newly added if not present.",
              "get_or_add_bgPr": "Return `p:bg/p:bgPr` grandchild.\n\nIf no such grandchild is present, any existing `p:bg` child is first removed and a new\ndefault `p:bg` with noFill settings is added.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_GradientFillProperties": {
            "type": "class",
            "doc": "`a:gradFill` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
              "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
              "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_NotesMaster": {
            "type": "class",
            "doc": "`p:notesMaster` element, root of a notes master part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_NotesSlide": {
            "type": "class",
            "doc": "`p:notes` element, root of a notes slide part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Slide": {
            "type": "class",
            "doc": "`p:sld` element, root element of a slide part (XML document).",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_childTnLst": "Return parent element for a new `p:video` child element.\n\nThe `p:video` element causes play controls to appear under a video\nshape (pic shape containing video). There can be more than one video\nshape on a slide, which causes the precondition to vary. It needs to\nhandle the case when there is no `p:sld/p:timing` element and when\nthat element already exists. If the case isn't simple, it just nukes\nwhat's there and adds a fresh one. This could theoretically remove\ndesired existing timing information, but there isn't any evidence\navailable to me one way or the other, so I've taken the simple\napproach.",
              "get_or_add_clrMapOvr": "Return the ``<p:clrMapOvr>`` child element, newly added if not present.",
              "get_or_add_timing": "Return the ``<p:timing>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideLayout": {
            "type": "class",
            "doc": "`p:sldLayout` element, root of a slide layout part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideLayoutIdList": {
            "type": "class",
            "doc": "`p:sldLayoutIdLst` element, child of `p:sldMaster`.\n\nContains references to the slide layouts that inherit from the slide master.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideLayoutIdListEntry": {
            "type": "class",
            "doc": "`p:sldLayoutId` element, child of `p:sldLayoutIdLst`.\n\nContains a reference to a slide layout.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideMaster": {
            "type": "class",
            "doc": "`p:sldMaster` element, root of a slide master part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_sldLayoutIdLst": "Return the ``<p:sldLayoutIdLst>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_SlideTiming": {
            "type": "class",
            "doc": "`p:timing` element, specifying animations and timed behaviors.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_tnLst": "Return the ``<p:tnLst>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TLMediaNodeVideo": {
            "type": "class",
            "doc": "`p:video` element, specifying video media details.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TimeNodeList": {
            "type": "class",
            "doc": "`p:tnLst` or `p:childTnList` element.",
            "methods": {
              "add_video": "Add a new `p:video` child element for movie having *shape_id*.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "Choice": {
            "type": "class",
            "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "OneAndOnlyOne": {
            "type": "class",
            "doc": "Defines a required child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "XsdString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "ZeroOrOneChoice": {
            "type": "class",
            "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          }
        }
      },
      "table": {
        "type": "module",
        "doc": "Custom element classes for table-related XML elements",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_GradientFillProperties": {
            "type": "class",
            "doc": "`a:gradFill` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
              "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
              "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Table": {
            "type": "class",
            "doc": "`a:tbl` custom element class",
            "methods": {
              "add_tr": "Return a newly created `a:tr` child element having its `h` attribute set to `height`.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_tblPr": "Return the ``<a:tblPr>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "iter_tcs": "Generate each `a:tc` element in this tbl.\n\n`a:tc` elements are generated left-to-right, top-to-bottom.",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "tc": "Return `a:tc` element at `row_idx`, `col_idx`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableCell": {
            "type": "class",
            "doc": "`a:tc` custom element class",
            "methods": {
              "append_ps_from": "Append `a:p` elements taken from `spanned_tc`.\n\nAny non-empty paragraph elements in `spanned_tc` are removed and appended to the\ntext-frame of this cell. If `spanned_tc` is left with no content after this process, a\nsingle empty `a:p` element is added to ensure the cell is compliant with the spec.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_tcPr": "Return the ``<a:tcPr>`` child element, newly added if not present.",
              "get_or_add_txBody": "Return the ``<a:txBody>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableCellProperties": {
            "type": "class",
            "doc": "`a:tcPr` custom element class",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
              "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
              "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
              "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
              "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
              "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableCol": {
            "type": "class",
            "doc": "`a:gridCol` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableGrid": {
            "type": "class",
            "doc": "`a:tblGrid` custom element class.",
            "methods": {
              "add_gridCol": "A newly appended `a:gridCol` child element having its `w` attribute set to `width`.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableProperties": {
            "type": "class",
            "doc": "`a:tblPr` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TableRow": {
            "type": "class",
            "doc": "`a:tr` custom element class.",
            "methods": {
              "add_tc": "A newly added minimal valid `a:tc` child element.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextBody": {
            "type": "class",
            "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
            "methods": {
              "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
              "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "Choice": {
            "type": "class",
            "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "MSO_VERTICAL_ANCHOR": {
            "type": "class",
            "doc": "Specifies the vertical alignment of text in a text frame.\n\nUsed with the `.vertical_anchor` property of the |TextFrame| object. Note that the\n`vertical_anchor` property can also have the value None, indicating there is no directly\nspecified vertical anchor setting and its effective value is inherited from its placeholder if\nit has one or from the theme. |None| may also be assigned to remove an explicitly specified\nvertical anchor setting.\n\nMS API Name: `MsoVerticalAnchor`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865255.aspx",
            "methods": {}
          },
          "OneAndOnlyOne": {
            "type": "class",
            "doc": "Defines a required child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ST_Coordinate": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_Coordinate32": {
            "type": "class",
            "doc": "xsd:union of ST_Coordinate32Unqualified, ST_UniversalMeasure",
            "methods": {}
          },
          "TcRange": {
            "type": "class",
            "doc": "A 2D block of `a:tc` cell elements in a table.\n\nThis object assumes the structure of the underlying table does not change during its lifetime.\nStructural changes in this context would be insertion or removal of rows or columns.\n\nThe client is expected to create, use, and then abandon an instance in the context of a single\nuser operation that is known to have no structural side-effects of this type.",
            "methods": {
              "iter_except_left_col_tcs": "Generate each `a:tc` element not in leftmost column of range.",
              "iter_except_top_row_tcs": "Generate each `a:tc` element in non-first rows of range.",
              "iter_left_col_tcs": "Generate each `a:tc` element in leftmost column of range.",
              "iter_tcs": "Generate each `a:tc` element in this range.\n\nCell elements are generated left-to-right, top-to-bottom.",
              "iter_top_row_tcs": "Generate each `a:tc` element in topmost row of range.",
              "move_content_to_origin": "Move all paragraphs in range to origin cell."
            }
          },
          "XsdBoolean": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XsdInt": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "ZeroOrOneChoice": {
            "type": "class",
            "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "text": {
        "type": "module",
        "doc": "Custom element classes for text-related XML elements",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_GradientFillProperties": {
            "type": "class",
            "doc": "`a:gradFill` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_gsLst": "Return the ``<a:gsLst>`` child element, newly added if not present.",
              "get_or_add_lin": "Return the ``<a:lin>`` child element, newly added if not present.",
              "get_or_add_path": "Return the ``<a:path>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_RegularTextRun": {
            "type": "class",
            "doc": "`a:r` custom element class",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextBody": {
            "type": "class",
            "doc": "`p:txBody` custom element class.\n\nAlso used for `c:txPr` in charts and perhaps other elements.",
            "methods": {
              "add_p": "Add a new ``<a:p>`` child element unconditionally, inserted in the correct sequence.",
              "clear_content": "Remove all `a:p` children, but leave any others.\n\ncf. lxml `_Element.clear()` method which removes all children.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "unclear_content": "Ensure p:txBody has at least one a:p child.\n\nIntuitively, reverse a \".clear_content()\" operation to minimum conformance with spec\n(single empty paragraph).",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextBodyProperties": {
            "type": "class",
            "doc": "`a:bodyPr` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_change_to_noAutofit": "Return the ``<a:noAutofit>`` child, replacing any other group element if found.",
              "get_or_change_to_normAutofit": "Return the ``<a:normAutofit>`` child, replacing any other group element if found.",
              "get_or_change_to_spAutoFit": "Return the ``<a:spAutoFit>`` child, replacing any other group element if found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextCharacterProperties": {
            "type": "class",
            "doc": "Custom element class for `a:rPr`, `a:defRPr`, and `a:endParaRPr`.\n\n'rPr' is short for 'run properties', and it corresponds to the |Font| proxy class.",
            "methods": {
              "add_hlinkClick": "Add an `a:hlinkClick` child element with r:id attribute set to `rId`.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_hlinkClick": "Return the ``<a:hlinkClick>`` child element, newly added if not present.",
              "get_or_add_latin": "Return the ``<a:latin>`` child element, newly added if not present.",
              "get_or_change_to_blipFill": "Return the ``<a:blipFill>`` child, replacing any other group element if found.",
              "get_or_change_to_gradFill": "Return the ``<a:gradFill>`` child, replacing any other group element if found.",
              "get_or_change_to_grpFill": "Return the ``<a:grpFill>`` child, replacing any other group element if found.",
              "get_or_change_to_noFill": "Return the ``<a:noFill>`` child, replacing any other group element if found.",
              "get_or_change_to_pattFill": "Return the ``<a:pattFill>`` child, replacing any other group element if found.",
              "get_or_change_to_solidFill": "Return the ``<a:solidFill>`` child, replacing any other group element if found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextField": {
            "type": "class",
            "doc": "`a:fld` field element, for either a slide number or date field.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
              "get_or_add_t": "Return the ``<a:t>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextFont": {
            "type": "class",
            "doc": "Custom element class for `a:latin`, `a:ea`, `a:cs`, and `a:sym`.\n\nThese occur as child elements of CT_TextCharacterProperties, e.g. `a:rPr`.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextLineBreak": {
            "type": "class",
            "doc": "`a:br` line break element",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_rPr": "Return the ``<a:rPr>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextNormalAutofit": {
            "type": "class",
            "doc": "`a:normAutofit` element specifying fit text to shape font reduction, etc.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextParagraph": {
            "type": "class",
            "doc": "`a:p` custom element class",
            "methods": {
              "add_br": "Return a newly appended `a:br` element.",
              "add_r": "Return a newly appended `a:r` element.",
              "append_text": "Append `a:r` and `a:br` elements to `p` based on `text`.\n\n        Any `\n` or `\u000b` (vertical-tab) characters in `text` delimit `a:r` (run) elements and\n        themselves are translated to `a:br` (line-break) elements. The vertical-tab character\n        appears in clipboard text from PowerPoint at \"soft\" line-breaks (new-line, but not new\n        paragraph).\n        ",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_endParaRPr": "Return the ``<a:endParaRPr>`` child element, newly added if not present.",
              "get_or_add_pPr": "Return the ``<a:pPr>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextParagraphProperties": {
            "type": "class",
            "doc": "`a:pPr` custom element class.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_defRPr": "Return the ``<a:defRPr>`` child element, newly added if not present.",
              "get_or_add_lnSpc": "Return the ``<a:lnSpc>`` child element, newly added if not present.",
              "get_or_add_spcAft": "Return the ``<a:spcAft>`` child element, newly added if not present.",
              "get_or_add_spcBef": "Return the ``<a:spcBef>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextSpacing": {
            "type": "class",
            "doc": "Used for `a:lnSpc`, `a:spcBef`, and `a:spcAft` elements.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_spcPct": "Return the ``<a:spcPct>`` child element, newly added if not present.",
              "get_or_add_spcPts": "Return the ``<a:spcPts>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "set_spcPct": "Set spacing to `value` lines, e.g. 1.75 lines.\n\nA ./a:spcPts child is removed if present.",
              "set_spcPts": "Set spacing to `value` points. A ./a:spcPct child is removed if present.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextSpacingPercent": {
            "type": "class",
            "doc": "`a:spcPct` element, specifying spacing in thousandths of a percent in its `val` attribute.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_TextSpacingPoint": {
            "type": "class",
            "doc": "`a:spcPts` element, specifying spacing in centipoints in its `val` attribute.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "Choice": {
            "type": "class",
            "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "InvalidXmlError": {
            "type": "class",
            "doc": "Raised when a value is encountered in the XML that is not valid according\nto the schema.",
            "methods": {}
          },
          "Length": {
            "type": "class",
            "doc": "Base class for length classes Inches, Emu, Cm, Mm, and Pt.\n\nProvides properties for converting length values to convenient units.",
            "methods": {}
          },
          "MSO_AUTO_SIZE": {
            "type": "class",
            "doc": "Determines the type of automatic sizing allowed.\n\nThe following names can be used to specify the automatic sizing behavior used to fit a shape's\ntext within the shape bounding box, for example::\n\n    from pptx.enum.text import MSO_AUTO_SIZE\n\n    shape.text_frame.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE\n\nThe word-wrap setting of the text frame interacts with the auto-size setting to determine the\nspecific auto-sizing behavior.\n\nNote that `TextFrame.auto_size` can also be set to |None|, which removes the auto size setting\naltogether. This causes the setting to be inherited, either from the layout placeholder, in the\ncase of a placeholder shape, or from the theme.\n\nMS API Name: `MsoAutoSize`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865367(v=office.15).aspx",
            "methods": {}
          },
          "MSO_LANGUAGE_ID": {
            "type": "class",
            "doc": "Specifies the language identifier.\n\nExample::\n\n    from pptx.enum.lang import MSO_LANGUAGE_ID\n\n    font.language_id = MSO_LANGUAGE_ID.POLISH\n\nMS API Name: `MsoLanguageId`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff862134.aspx",
            "methods": {}
          },
          "MSO_TEXT_UNDERLINE_TYPE": {
            "type": "class",
            "doc": "Indicates the type of underline for text. Used with\n:attr:`.Font.underline` to specify the style of text underlining.\n\nAlias: ``MSO_UNDERLINE``\n\nExample::\n\n    from pptx.enum.text import MSO_UNDERLINE\n\n    run.font.underline = MSO_UNDERLINE.DOUBLE_LINE\n\nMS API Name: `MsoTextUnderlineType`\n\nhttp://msdn.microsoft.com/en-us/library/aa432699.aspx",
            "methods": {}
          },
          "MSO_VERTICAL_ANCHOR": {
            "type": "class",
            "doc": "Specifies the vertical alignment of text in a text frame.\n\nUsed with the `.vertical_anchor` property of the |TextFrame| object. Note that the\n`vertical_anchor` property can also have the value None, indicating there is no directly\nspecified vertical anchor setting and its effective value is inherited from its placeholder if\nit has one or from the theme. |None| may also be assigned to remove an explicitly specified\nvertical anchor setting.\n\nMS API Name: `MsoVerticalAnchor`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865255.aspx",
            "methods": {}
          },
          "OneAndOnlyOne": {
            "type": "class",
            "doc": "Defines a required child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OneOrMore": {
            "type": "class",
            "doc": "Defines a repeating child element for MetaOxmlElement that must appear at least once.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "PP_PARAGRAPH_ALIGNMENT": {
            "type": "class",
            "doc": "Specifies the horizontal alignment for one or more paragraphs.\n\nAlias: `PP_ALIGN`\n\nExample::\n\n    from pptx.enum.text import PP_ALIGN\n\n    shape.paragraphs[0].alignment = PP_ALIGN.CENTER\n\nMS API Name: `PpParagraphAlignment`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff745375(v=office.15).aspx",
            "methods": {}
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ST_Coordinate32": {
            "type": "class",
            "doc": "xsd:union of ST_Coordinate32Unqualified, ST_UniversalMeasure",
            "methods": {}
          },
          "ST_TextFontScalePercentOrPercentString": {
            "type": "class",
            "doc": "Valid values for the `fontScale` attribute of ``<a:normAutofit>``.\nTranslates to a float value.",
            "methods": {}
          },
          "ST_TextFontSize": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextIndentLevelType": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextSpacingPercentOrPercentString": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextSpacingPoint": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextTypeface": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextWrappingType": {
            "type": "class",
            "doc": "Valid values for <a:bodyPr wrap=\"\"> attribute",
            "methods": {}
          },
          "XsdBoolean": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "ZeroOrOneChoice": {
            "type": "class",
            "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          }
        }
      },
      "theme": {
        "type": "module",
        "doc": "lxml custom element classes for theme-related XML elements.",
        "members": {
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_OfficeStyleSheet": {
            "type": "class",
            "doc": "``<a:theme>`` element, root of a theme part",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          }
        }
      },
      "xmlchemy": {
        "type": "module",
        "doc": "Base and meta classes enabling declarative definition of custom element classes.",
        "members": {
          "AttributeType": {
            "type": "class",
            "doc": "Interface for an object that can act as an attribute type.\n\nAn attribute-type specifies how values are transformed to and from the XML \"string\" value of the\nattribute.",
            "methods": {}
          },
          "BaseAttribute": {
            "type": "class",
            "doc": "Base class for OptionalAttribute and RequiredAttribute, providing common methods.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "BaseOxmlElement": {
            "type": "class",
            "doc": "Effective base class for all custom element classes.\n\nAdds standardized behavior to all classes in one place.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "Choice": {
            "type": "class",
            "doc": "Defines a child element belonging to a group, only one of which may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "ElementBase": {
            "type": "class",
            "doc": "ElementBase(*children, attrib=None, nsmap=None, **_extra)\n\nThe public Element class.  All custom Element classes must inherit\nfrom this one.  To create an Element, use the `Element()` factory.\n\nBIG FAT WARNING: Subclasses *must not* override __init__ or\n__new__ as it is absolutely undefined when these objects will be\ncreated or destroyed.  All persistent state of Elements must be\nstored in the underlying XML.  If you really need to initialize\nthe object after creation, you can implement an ``_init(self)``\nmethod that will be called directly after object creation.\n\nSubclasses of this class can be instantiated to create a new\nElement.  By default, the tag name will be the class name and the\nnamespace will be empty.  You can modify this with the following\nclass attributes:\n\n* TAG - the tag name, possibly containing a namespace in Clark\n  notation\n\n* NAMESPACE - the default namespace URI, unless provided as part\n  of the TAG attribute.\n\n* HTML - flag if the class is an HTML tag, as opposed to an XML\n  tag.  This only applies to un-namespaced tags and defaults to\n  false (i.e. XML).\n\n* PARSER - the parser that provides the configuration for the\n  newly created document.  Providing an HTML parser here will\n  default to creating an HTML element.\n\nIn user code, the latter three are commonly inherited in class\nhierarchies that implement a common namespace.",
            "methods": {}
          },
          "InvalidXmlError": {
            "type": "class",
            "doc": "Raised when a value is encountered in the XML that is not valid according\nto the schema.",
            "methods": {}
          },
          "MetaOxmlElement": {
            "type": "class",
            "doc": "Metaclass for BaseOxmlElement.",
            "methods": {}
          },
          "NamespacePrefixedTag": {
            "type": "class",
            "doc": "Value object that knows the semantics of an XML tag having a namespace prefix.",
            "methods": {}
          },
          "OneAndOnlyOne": {
            "type": "class",
            "doc": "Defines a required child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OneOrMore": {
            "type": "class",
            "doc": "Defines a repeating child element for MetaOxmlElement that must appear at least once.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "OptionalAttribute": {
            "type": "class",
            "doc": "Defines an optional attribute on a custom element class.\n\nAn optional attribute returns a default value when not present for reading. When assigned\n|None|, the attribute is removed.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "Protocol": {
            "type": "class",
            "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing), for example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
            "methods": {}
          },
          "RequiredAttribute": {
            "type": "class",
            "doc": "Defines a required attribute on a custom element class.\n\nA required attribute is assumed to be present for reading, so does not have a default value;\nits actual value is always used. If missing on read, an |InvalidXmlError| is raised. It also\ndoes not remove the attribute if |None| is assigned. Assigning |None| raises |TypeError| or\n|ValueError|, depending on the simple type of the attribute.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "XmlString": {
            "type": "class",
            "doc": "Provides string comparison override suitable for serialized XML; useful for tests.",
            "methods": {}
          },
          "ZeroOrMore": {
            "type": "class",
            "doc": "Defines an optional repeating child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to *element_cls*."
            }
          },
          "ZeroOrOne": {
            "type": "class",
            "doc": "Defines an optional child element for MetaOxmlElement.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "ZeroOrOneChoice": {
            "type": "class",
            "doc": "An `EG_*` element group where at most one of its members may appear as a child.",
            "methods": {
              "populate_class_members": "Add the appropriate methods to `element_cls`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      }
    }
  },
  "package": {
    "type": "module",
    "doc": "Overall .pptx package.",
    "members": {
      "CorePropertiesPart": {
        "type": "class",
        "doc": "Corresponds to part named `/docProps/core.xml`.\n\nContains the core document properties for this document package.",
        "methods": {
          "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
          "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      },
      "IO": {
        "type": "class",
        "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
        "methods": {
          "close": "No documentation",
          "fileno": "No documentation",
          "flush": "No documentation",
          "isatty": "No documentation",
          "read": "No documentation",
          "readable": "No documentation",
          "readline": "No documentation",
          "readlines": "No documentation",
          "seek": "No documentation",
          "seekable": "No documentation",
          "tell": "No documentation",
          "truncate": "No documentation",
          "writable": "No documentation",
          "write": "No documentation",
          "writelines": "No documentation"
        }
      },
      "Image": {
        "type": "class",
        "doc": "Immutable value object representing an image such as a JPEG, PNG, or GIF.",
        "methods": {}
      },
      "ImagePart": {
        "type": "class",
        "doc": "An image part.\n\nAn image part generally has a partname matching the regex `ppt/media/image[1-9][0-9]*.*`.",
        "methods": {
          "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "scale": "Return scaled image dimensions in EMU based on the combination of parameters supplied.\n\nIf `scaled_cx` and `scaled_cy` are both |None|, the native image size is returned. If\nneither `scaled_cx` nor `scaled_cy` is |None|, their values are returned unchanged. If a\nvalue is provided for either `scaled_cx` or `scaled_cy` and the other is |None|, the\nmissing value is calculated such that the image's aspect ratio is preserved.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      },
      "MediaPart": {
        "type": "class",
        "doc": "A media part, containing an audio or video resource.\n\nA media part generally has a partname matching the regex\n`ppt/media/media[1-9][0-9]*.*`.",
        "methods": {
          "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      },
      "OpcPackage": {
        "type": "class",
        "doc": "Main API class for |python-opc|.\n\nA new instance is constructed by calling the :meth:`open` classmethod with a path to a package\nfile or file-like object containing a package (.pptx file).",
        "methods": {
          "drop_rel": "Remove relationship identified by `rId`.",
          "iter_parts": "Generate exactly one reference to each part in the package.",
          "iter_rels": "Generate exactly one reference to each relationship in package.\n\nPerforms a depth-first traversal of the rels graph.",
          "next_partname": "Return |PackURI| next available partname matching `tmpl`.\n\n`tmpl` is a printf (%)-style template string containing a single replacement item, a '%d'\nto be used to insert the integer portion of the partname. Example:\n'/ppt/slides/slide%d.xml'",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "save": "Save this package to `pkg_file`.\n\n`file` can be either a path to a file (a string) or a file-like object.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      },
      "PackURI": {
        "type": "class",
        "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
        "methods": {
          "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
          "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
        }
      },
      "Package": {
        "type": "class",
        "doc": "An overall .pptx package.",
        "methods": {
          "drop_rel": "Remove relationship identified by `rId`.",
          "get_or_add_image_part": "Return an |ImagePart| object containing the image in *image_file*. If\nthe image part already exists in this package, it is reused,\notherwise a new one is created.",
          "get_or_add_media_part": "Return a |MediaPart| object containing the media in *media*.\n\nIf a media part for this media bytestream (\"file\") is already present\nin this package, it is reused, otherwise a new one is created.",
          "iter_parts": "Generate exactly one reference to each part in the package.",
          "iter_rels": "Generate exactly one reference to each relationship in package.\n\nPerforms a depth-first traversal of the rels graph.",
          "next_image_partname": "Return a |PackURI| instance representing the next available image partname.\n\nPartname uses the next available sequence number. *ext* is used as the extention on the\nreturned partname.",
          "next_media_partname": "Return |PackURI| instance for next available media partname.\n\nPartname is first available, starting at sequence number 1. Empty\nsequence numbers are reused. *ext* is used as the extension on the\nreturned partname.",
          "next_partname": "Return |PackURI| next available partname matching `tmpl`.\n\n`tmpl` is a printf (%)-style template string containing a single replacement item, a '%d'\nto be used to insert the integer portion of the partname. Example:\n'/ppt/slides/slide%d.xml'",
          "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
          "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
          "related_part": "Return related |Part| subtype identified by `rId`.",
          "save": "Save this package to `pkg_file`.\n\n`file` can be either a path to a file (a string) or a file-like object.",
          "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
        }
      },
      "RT": {
        "type": "class",
        "doc": "No documentation",
        "methods": {}
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "parts": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "chart": {
        "type": "module",
        "doc": "Chart part objects, including Chart and Charts.",
        "members": {
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "Chart": {
            "type": "class",
            "doc": "A chart object.",
            "methods": {
              "replace_data": "Use the categories and series values in the |ChartData| object\n*chart_data* to replace those in the XML and Excel worksheet for this\nchart."
            }
          },
          "ChartPart": {
            "type": "class",
            "doc": "A chart part.\n\nCorresponds to parts having partnames matching ppt/charts/chart[1-9][0-9]*.xml",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "ChartWorkbook": {
            "type": "class",
            "doc": "Provides access to external chart data in a linked or embedded Excel workbook.",
            "methods": {
              "update_from_xlsx_blob": "Replace the Excel spreadsheet in the related |EmbeddedXlsxPart| with\nthe Excel binary in *xlsx_blob*, adding a new |EmbeddedXlsxPart| if\nthere isn't one."
            }
          },
          "EmbeddedXlsxPart": {
            "type": "class",
            "doc": "An Excel file stored in a part.\n\nThis part-type arises as the data source for a chart, but may also be the OLE-object\nfor an embedded object shape.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "RT": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "XmlPart": {
            "type": "class",
            "doc": "Base class for package parts containing an XML payload, which is most of them.\n\nProvides additional methods to the |Part| base class that take care of parsing and\nreserializing the XML payload and managing relationships to other parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "coreprops": {
        "type": "module",
        "doc": "Core properties part, corresponds to ``/docProps/core.xml`` part in package.",
        "members": {
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "CT_CoreProperties": {
            "type": "class",
            "doc": "`cp:coreProperties` element.\n\nThe root element of the Core Properties part stored as `/docProps/core.xml`. Implements many\nof the Dublin Core document metadata elements. String elements resolve to an empty string ('')\nif the element is not present in the XML. String elements are limited in length to 255 unicode\ncharacters.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_category": "Return the ``<cp:category>`` child element, newly added if not present.",
              "get_or_add_contentStatus": "Return the ``<cp:contentStatus>`` child element, newly added if not present.",
              "get_or_add_created": "Return the ``<dcterms:created>`` child element, newly added if not present.",
              "get_or_add_creator": "Return the ``<dc:creator>`` child element, newly added if not present.",
              "get_or_add_description": "Return the ``<dc:description>`` child element, newly added if not present.",
              "get_or_add_identifier": "Return the ``<dc:identifier>`` child element, newly added if not present.",
              "get_or_add_keywords": "Return the ``<cp:keywords>`` child element, newly added if not present.",
              "get_or_add_language": "Return the ``<dc:language>`` child element, newly added if not present.",
              "get_or_add_lastModifiedBy": "Return the ``<cp:lastModifiedBy>`` child element, newly added if not present.",
              "get_or_add_lastPrinted": "Return the ``<cp:lastPrinted>`` child element, newly added if not present.",
              "get_or_add_modified": "Return the ``<dcterms:modified>`` child element, newly added if not present.",
              "get_or_add_revision": "Return the ``<cp:revision>`` child element, newly added if not present.",
              "get_or_add_subject": "Return the ``<dc:subject>`` child element, newly added if not present.",
              "get_or_add_title": "Return the ``<dc:title>`` child element, newly added if not present.",
              "get_or_add_version": "Return the ``<cp:version>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "new_coreProperties": "Return a new `cp:coreProperties` element",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CorePropertiesPart": {
            "type": "class",
            "doc": "Corresponds to part named `/docProps/core.xml`.\n\nContains the core document properties for this document package.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          },
          "XmlPart": {
            "type": "class",
            "doc": "Base class for package parts containing an XML payload, which is most of them.\n\nProvides additional methods to the |Part| base class that take care of parsing and\nreserializing the XML payload and managing relationships to other parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          }
        }
      },
      "embeddedpackage": {
        "type": "module",
        "doc": "Embedded Package part objects.\n\n\"Package\" in this context means another OPC package, i.e. a DOCX, PPTX, or XLSX \"file\".",
        "members": {
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "EmbeddedDocxPart": {
            "type": "class",
            "doc": "A Word .docx file stored in a part.\n\nThis part-type arises when a Word document appears as an embedded OLE-object shape.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "EmbeddedPackagePart": {
            "type": "class",
            "doc": "A distinct OPC package, e.g. an Excel file, embedded in this PPTX package.\n\nHas a partname like: `ppt/embeddings/Microsoft_Excel_Sheet1.xlsx`.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "EmbeddedPptxPart": {
            "type": "class",
            "doc": "A PowerPoint file stored in a part.\n\nThis part-type arises when a PowerPoint presentation (.pptx file) appears as an\nembedded OLE-object shape.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "EmbeddedXlsxPart": {
            "type": "class",
            "doc": "An Excel file stored in a part.\n\nThis part-type arises as the data source for a chart, but may also be the OLE-object\nfor an embedded object shape.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PROG_ID": {
            "type": "class",
            "doc": "One-off Enum-like object for progId values.\n\nIndicates the type of an OLE object in terms of the program used to open it.\n\nA member of this enumeration can be used in a `SlideShapes.add_ole_object()` call to\nspecify a Microsoft Office file-type (Excel, PowerPoint, or Word), which will\nthen not require several of the arguments required to embed other object types.\n\nExample::\n\n    from pptx.enum.shapes import PROG_ID\n    from pptx.util import Inches\n\n    embedded_xlsx_shape = slide.shapes.add_ole_object(\n        \"workbook.xlsx\", PROG_ID.XLSX, left=Inches(1), top=Inches(1)\n    )\n    assert embedded_xlsx_shape.ole_format.prog_id == \"Excel.Sheet.12\"",
            "methods": {}
          },
          "Part": {
            "type": "class",
            "doc": "Base class for package parts.\n\nProvides common properties and methods, but intended to be subclassed in client code to\nimplement specific part behaviors. Also serves as the default class for parts that are not yet\ngiven specific behaviors.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          }
        }
      },
      "image": {
        "type": "module",
        "doc": "ImagePart and related objects.",
        "members": {
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "Image": {
            "type": "class",
            "doc": "Immutable value object representing an image such as a JPEG, PNG, or GIF.",
            "methods": {}
          },
          "ImagePart": {
            "type": "class",
            "doc": "An image part.\n\nAn image part generally has a partname matching the regex `ppt/media/image[1-9][0-9]*.*`.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "scale": "Return scaled image dimensions in EMU based on the combination of parameters supplied.\n\nIf `scaled_cx` and `scaled_cy` are both |None|, the native image size is returned. If\nneither `scaled_cx` nor `scaled_cy` is |None|, their values are returned unchanged. If a\nvalue is provided for either `scaled_cx` or `scaled_cy` and the other is |None|, the\nmissing value is calculated such that the image's aspect ratio is preserved.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "Part": {
            "type": "class",
            "doc": "Base class for package parts.\n\nProvides common properties and methods, but intended to be subclassed in client code to\nimplement specific part behaviors. Also serves as the default class for parts that are not yet\ngiven specific behaviors.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "media": {
        "type": "module",
        "doc": "MediaPart and related objects.",
        "members": {
          "MediaPart": {
            "type": "class",
            "doc": "A media part, containing an audio or video resource.\n\nA media part generally has a partname matching the regex\n`ppt/media/media[1-9][0-9]*.*`.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "Part": {
            "type": "class",
            "doc": "Base class for package parts.\n\nProvides common properties and methods, but intended to be subclassed in client code to\nimplement specific part behaviors. Also serves as the default class for parts that are not yet\ngiven specific behaviors.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "presentation": {
        "type": "module",
        "doc": "Presentation part, the main part in a .pptx package.",
        "members": {
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "NotesMasterPart": {
            "type": "class",
            "doc": "Notes master part.\n\nCorresponds to package file `ppt/notesMasters/notesMaster1.xml`.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          },
          "Presentation": {
            "type": "class",
            "doc": "PresentationML (PML) presentation.\n\nNot intended to be constructed directly. Use :func:`pptx.Presentation` to open or\ncreate a presentation.",
            "methods": {
              "save": "Writes this presentation to `file`.\n\n`file` can be either a file-path or a file-like object open for writing bytes."
            }
          },
          "PresentationPart": {
            "type": "class",
            "doc": "Top level class in object model.\n\nRepresents the contents of the /ppt directory of a .pptx file.",
            "methods": {
              "add_slide": "Return (rId, slide) pair of a newly created blank slide.\n\nNew slide inherits appearance from `slide_layout`.",
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_slide": "Return optional related |Slide| object identified by `slide_id`.\n\nReturns |None| if no slide with `slide_id` is related to this presentation.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "related_slide": "Return |Slide| object for related |SlidePart| related by `rId`.",
              "related_slide_master": "Return |SlideMaster| object for |SlideMasterPart| related by `rId`.",
              "rename_slide_parts": "Assign incrementing partnames to the slide parts identified by `rIds`.\n\nPartnames are like `/ppt/slides/slide9.xml` and are assigned in the order their id appears\nin the `rIds` sequence. The name portion is always `slide`. The number part forms a\ncontinuous sequence starting at 1 (e.g. 1, 2, ... 10, ...). The extension is always\n`.xml`.",
              "save": "Save this presentation package to `path_or_stream`.\n\n`path_or_stream` can be either a path to a filesystem location (a string) or a\nfile-like object.",
              "slide_id": "Return the slide-id associated with `slide_part`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "RT": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "SlidePart": {
            "type": "class",
            "doc": "Slide part. Corresponds to package files ppt/slides/slide[1-9][0-9]*.xml.",
            "methods": {
              "add_chart_part": "Return str rId of new |ChartPart| object containing chart of `chart_type`.\n\nThe chart depicts `chart_data` and is related to the slide contained in this\npart by `rId`.",
              "add_embedded_ole_object_part": "Return rId of newly-added OLE-object part formed from `ole_object_file`.",
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "get_or_add_video_media_part": "Return rIds for media and video relationships to media part.\n\nA new |MediaPart| object is created if it does not already exist\n(such as would occur if the same video appeared more than once in\n a presentation). Two relationships to the media part are created,\none each with MEDIA and VIDEO relationship types. The need for two\nappears to be for legacy support for an earlier (pre-Office 2010)\nPowerPoint media embedding strategy.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "XmlPart": {
            "type": "class",
            "doc": "Base class for package parts containing an XML payload, which is most of them.\n\nProvides additional methods to the |Part| base class that take care of parsing and\nreserializing the XML payload and managing relationships to other parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "slide": {
        "type": "module",
        "doc": "Slide and related objects.",
        "members": {
          "BaseSlidePart": {
            "type": "class",
            "doc": "Base class for slide parts.\n\nThis includes slide, slide-layout, and slide-master parts, but also notes-slide,\nnotes-master, and handout-master parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "CT_NotesMaster": {
            "type": "class",
            "doc": "`p:notesMaster` element, root of a notes master part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_NotesSlide": {
            "type": "class",
            "doc": "`p:notes` element, root of a notes slide part.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_OfficeStyleSheet": {
            "type": "class",
            "doc": "``<a:theme>`` element, root of a theme part",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Slide": {
            "type": "class",
            "doc": "`p:sld` element, root element of a slide part (XML document).",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_childTnLst": "Return parent element for a new `p:video` child element.\n\nThe `p:video` element causes play controls to appear under a video\nshape (pic shape containing video). There can be more than one video\nshape on a slide, which causes the precondition to vary. It needs to\nhandle the case when there is no `p:sld/p:timing` element and when\nthat element already exists. If the case isn't simple, it just nukes\nwhat's there and adds a fresh one. This could theoretically remove\ndesired existing timing information, but there isn't any evidence\navailable to me one way or the other, so I've taken the simple\napproach.",
              "get_or_add_clrMapOvr": "Return the ``<p:clrMapOvr>`` child element, newly added if not present.",
              "get_or_add_timing": "Return the ``<p:timing>`` child element, newly added if not present.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ChartPart": {
            "type": "class",
            "doc": "A chart part.\n\nCorresponds to parts having partnames matching ppt/charts/chart[1-9][0-9]*.xml",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "EmbeddedPackagePart": {
            "type": "class",
            "doc": "A distinct OPC package, e.g. an Excel file, embedded in this PPTX package.\n\nHas a partname like: `ppt/embeddings/Microsoft_Excel_Sheet1.xlsx`.",
            "methods": {
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "NotesMaster": {
            "type": "class",
            "doc": "Proxy for the notes master XML document.\n\nProvides access to shapes, the most commonly used of which are placeholders.",
            "methods": {}
          },
          "NotesMasterPart": {
            "type": "class",
            "doc": "Notes master part.\n\nCorresponds to package file `ppt/notesMasters/notesMaster1.xml`.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "NotesSlide": {
            "type": "class",
            "doc": "Notes slide object.\n\nProvides access to slide notes placeholder and other shapes on the notes handout\npage.",
            "methods": {
              "clone_master_placeholders": "Selectively add placeholder shape elements from `notes_master`.\n\nSelected placeholder shape elements from `notes_master` are added to the shapes\ncollection of this notes slide. Z-order of placeholders is preserved. Certain\nplaceholders (header, date, footer) are not cloned."
            }
          },
          "NotesSlidePart": {
            "type": "class",
            "doc": "Notes slide part.\n\nContains the slide notes content and the layout for the slide handout page.\nCorresponds to package file `ppt/notesSlides/notesSlide[1-9][0-9]*.xml`.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "PROG_ID": {
            "type": "class",
            "doc": "One-off Enum-like object for progId values.\n\nIndicates the type of an OLE object in terms of the program used to open it.\n\nA member of this enumeration can be used in a `SlideShapes.add_ole_object()` call to\nspecify a Microsoft Office file-type (Excel, PowerPoint, or Word), which will\nthen not require several of the arguments required to embed other object types.\n\nExample::\n\n    from pptx.enum.shapes import PROG_ID\n    from pptx.util import Inches\n\n    embedded_xlsx_shape = slide.shapes.add_ole_object(\n        \"workbook.xlsx\", PROG_ID.XLSX, left=Inches(1), top=Inches(1)\n    )\n    assert embedded_xlsx_shape.ole_format.prog_id == \"Excel.Sheet.12\"",
            "methods": {}
          },
          "PackURI": {
            "type": "class",
            "doc": "Proxy for a pack URI (partname).\n\nProvides utility properties the baseURI and the filename slice. Behaves as |str| otherwise.",
            "methods": {
              "from_rel_ref": "Construct an absolute pack URI formed by translating `relative_ref` onto `baseURI`.",
              "relative_ref": "Return string containing relative reference to package item from `baseURI`.\n\nE.g. PackURI(\"/ppt/slideLayouts/slideLayout1.xml\") would return\n\"../slideLayouts/slideLayout1.xml\" for baseURI \"/ppt/slides\"."
            }
          },
          "RT": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "Slide": {
            "type": "class",
            "doc": "Slide object. Provides access to shapes and slide-level properties.",
            "methods": {}
          },
          "SlideLayout": {
            "type": "class",
            "doc": "Slide layout object.\n\nProvides access to placeholders, regular shapes, and slide layout-level properties.",
            "methods": {
              "iter_cloneable_placeholders": "Generate layout-placeholders on this slide-layout that should be cloned to a new slide.\n\nUsed when creating a new slide from this slide-layout."
            }
          },
          "SlideLayoutPart": {
            "type": "class",
            "doc": "Slide layout part.\n\nCorresponds to package files ``ppt/slideLayouts/slideLayout[1-9][0-9]*.xml``.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "SlideMaster": {
            "type": "class",
            "doc": "Slide master object.\n\nProvides access to slide layouts. Access to placeholders, regular shapes, and slide master-level\nproperties is inherited from |_BaseMaster|.",
            "methods": {}
          },
          "SlideMasterPart": {
            "type": "class",
            "doc": "Slide master part.\n\nCorresponds to package files ppt/slideMasters/slideMaster[1-9][0-9]*.xml.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "related_slide_layout": "Return |SlideLayout| related to this slide-master by key `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "SlidePart": {
            "type": "class",
            "doc": "Slide part. Corresponds to package files ppt/slides/slide[1-9][0-9]*.xml.",
            "methods": {
              "add_chart_part": "Return str rId of new |ChartPart| object containing chart of `chart_type`.\n\nThe chart depicts `chart_data` and is related to the slide contained in this\npart by `rId`.",
              "add_embedded_ole_object_part": "Return rId of newly-added OLE-object part formed from `ole_object_file`.",
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "get_image": "Return an |Image| object containing the image related to this slide by *rId*.\n\nRaises |KeyError| if no image is related by that id, which would generally indicate a\ncorrupted .pptx file.",
              "get_or_add_image_part": "Return `(image_part, rId)` pair corresponding to `image_file`.\n\nThe returned |ImagePart| object contains the image in `image_file` and is\nrelated to this slide with the key `rId`. If either the image part or\nrelationship already exists, they are reused, otherwise they are newly created.",
              "get_or_add_video_media_part": "Return rIds for media and video relationships to media part.\n\nA new |MediaPart| object is created if it does not already exist\n(such as would occur if the same video appeared more than once in\n a presentation). Two relationships to the media part are created,\none each with MEDIA and VIDEO relationship types. The need for two\nappears to be for legacy support for an earlier (pre-Office 2010)\nPowerPoint media embedding strategy.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "XmlPart": {
            "type": "class",
            "doc": "Base class for package parts containing an XML payload, which is most of them.\n\nProvides additional methods to the |Part| base class that take care of parsing and\nreserializing the XML payload and managing relationships to other parts.",
            "methods": {
              "drop_rel": "Remove relationship identified by `rId` if its reference count is under 2.\n\nRelationships with a reference count of 0 are implicit relationships. Note that only XML\nparts can drop relationships.",
              "load_rels_from_xml": "load _Relationships for this part from `xml_rels`.\n\nPart references are resolved using the `parts` dict that maps each partname to the loaded\npart with that partname. These relationships are loaded from a serialized package and so\nalready have assigned rIds. This method is only used during package loading.",
              "part_related_by": "Return (single) part having relationship to this package of `reltype`.\n\nRaises |KeyError| if no such relationship is found and |ValueError| if more than one such\nrelationship is found.",
              "relate_to": "Return rId key of relationship of `reltype` to `target`.\n\nIf such a relationship already exists, its rId is returned. Otherwise the relationship is\nadded and its new rId returned.",
              "related_part": "Return related |Part| subtype identified by `rId`.",
              "target_ref": "Return URL contained in target ref of relationship identified by `rId`."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      }
    }
  },
  "presentation": {
    "type": "module",
    "doc": "Main presentation object.",
    "members": {
      "IO": {
        "type": "class",
        "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
        "methods": {
          "close": "No documentation",
          "fileno": "No documentation",
          "flush": "No documentation",
          "isatty": "No documentation",
          "read": "No documentation",
          "readable": "No documentation",
          "readline": "No documentation",
          "readlines": "No documentation",
          "seek": "No documentation",
          "seekable": "No documentation",
          "tell": "No documentation",
          "truncate": "No documentation",
          "writable": "No documentation",
          "write": "No documentation",
          "writelines": "No documentation"
        }
      },
      "PartElementProxy": {
        "type": "class",
        "doc": "Provides common members for proxy-objects that wrap a part's root element, e.g. `p:sld`.",
        "methods": {}
      },
      "Presentation": {
        "type": "class",
        "doc": "PresentationML (PML) presentation.\n\nNot intended to be constructed directly. Use :func:`pptx.Presentation` to open or\ncreate a presentation.",
        "methods": {
          "save": "Writes this presentation to `file`.\n\n`file` can be either a file-path or a file-like object open for writing bytes."
        }
      },
      "SlideMasters": {
        "type": "class",
        "doc": "Sequence of |SlideMaster| objects belonging to a presentation.\n\nHas list access semantics, supporting indexed access, len(), and iteration.",
        "methods": {}
      },
      "Slides": {
        "type": "class",
        "doc": "Sequence of slides belonging to an instance of |Presentation|.\n\nHas list semantics for access to individual slides. Supports indexed access, len(), and\niteration.",
        "methods": {
          "add_slide": "Return a newly added slide that inherits layout from `slide_layout`.",
          "get": "Return the slide identified by int `slide_id` in this presentation.\n\nReturns `default` if not found.",
          "index": "Map `slide` to its zero-based position in this slide sequence.\n\nRaises |ValueError| on *slide* not present."
        }
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "shapes": {
    "type": "module",
    "doc": "Objects used across sub-package.",
    "members": {
      "Subshape": {
        "type": "class",
        "doc": "Provides access to the containing part for drawing elements that occur below a shape.\n\nAccess to the part is required for example to add or drop a relationship. Provides\n`self._parent` attribute to subclasses.",
        "methods": {}
      },
      "autoshape": {
        "type": "module",
        "doc": "Autoshape-related objects such as Shape and Adjustment.",
        "members": {
          "Adjustment": {
            "type": "class",
            "doc": "An adjustment value for an autoshape.\n\nAn adjustment value corresponds to the position of an adjustment handle on an auto shape.\nAdjustment handles are the small yellow diamond-shaped handles that appear on certain auto\nshapes and allow the outline of the shape to be adjusted. For example, a rounded rectangle has\nan adjustment handle that allows the radius of its corner rounding to be adjusted.\n\nValues are |float| and generally range from 0.0 to 1.0, although the value can be negative or\ngreater than 1.0 in certain circumstances.",
            "methods": {}
          },
          "AdjustmentCollection": {
            "type": "class",
            "doc": "Sequence of |Adjustment| instances for an auto shape.\n\nEach represents an available adjustment for a shape of its type. Supports `len()` and indexed\naccess, e.g. `shape.adjustments[1] = 0.15`.",
            "methods": {}
          },
          "AutoShapeType": {
            "type": "class",
            "doc": "Provides access to metadata for an auto-shape of type identified by `autoshape_type_id`.\n\nInstances are cached, so no more than one instance for a particular auto shape type is in\nmemory.\n\nInstances provide the following attributes:\n\n.. attribute:: autoshape_type_id\n\n   Integer uniquely identifying this auto shape type. Corresponds to a\n   value in `pptx.constants.MSO` like `MSO_SHAPE.ROUNDED_RECTANGLE`.\n\n.. attribute:: basename\n\n   Base part of shape name for auto shapes of this type, e.g. `Rounded\n   Rectangle` becomes `Rounded Rectangle 99` when the distinguishing\n   integer is added to the shape name.\n\n.. attribute:: prst\n\n   String identifier for this auto shape type used in the `a:prstGeom`\n   element.",
            "methods": {}
          },
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "FillFormat": {
            "type": "class",
            "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
            "methods": {
              "background": "Sets the fill type to noFill, i.e. transparent.",
              "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
              "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
              "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
            }
          },
          "LineFormat": {
            "type": "class",
            "doc": "Provides access to line properties such as color, style, and width.\n\nA LineFormat object is typically accessed via the ``.line`` property of\na shape such as |Shape| or |Picture|.",
            "methods": {}
          },
          "MSO_AUTO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "Number": {
            "type": "class",
            "doc": "All numbers inherit from this class.\n\nIf you just want to check if an argument x is a number, without\ncaring what kind, use isinstance(x, Number).",
            "methods": {}
          },
          "Shape": {
            "type": "class",
            "doc": "A shape that can appear on a slide.\n\nCorresponds to the `p:sp` element that can appear in any of the slide-type parts\n(slide, slideLayout, slideMaster, notesPage, notesMaster, handoutMaster).",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "TextFrame": {
            "type": "class",
            "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
            "methods": {
              "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
              "clear": "Remove all paragraphs except one empty one.",
              "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "base": {
        "type": "module",
        "doc": "Base shape-related objects such as BaseShape.",
        "members": {
          "ActionSetting": {
            "type": "class",
            "doc": "Properties specifying how a shape or run reacts to mouse actions.",
            "methods": {}
          },
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "ElementProxy": {
            "type": "class",
            "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
            "methods": {}
          },
          "ShadowFormat": {
            "type": "class",
            "doc": "Provides access to shadow effect on a shape.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "connector": {
        "type": "module",
        "doc": "Connector (line) shape and related objects.\n\nA connector is a line shape having end-points that can be connected to other\nobjects (but not to other connectors). A connector can be straight, have\nelbows, or can be curved.",
        "members": {
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "Connector": {
            "type": "class",
            "doc": "Connector (line) shape.\n\nA connector is a linear shape having end-points that can be connected to\nother objects (but not to other connectors). A connector can be straight,\nhave elbows, or can be curved.",
            "methods": {
              "begin_connect": "**EXPERIMENTAL** - *The current implementation only works properly\nwith rectangular shapes, such as pictures and rectangles. Use with\nother shape types may cause unexpected visual alignment of the\nconnected end-point and could lead to a load error if cxn_pt_idx\nexceeds the connection point count available on the connected shape.\nThat said, a quick test should reveal what to expect when using this\nmethod with other shape types.*\n\nConnect the beginning of this connector to *shape* at the connection\npoint specified by *cxn_pt_idx*. Each shape has zero or more\nconnection points and they are identified by index, starting with 0.\nGenerally, the first connection point of a shape is at the top center\nof its bounding box and numbering proceeds counter-clockwise from\nthere. However this is only a convention and may vary, especially\nwith non built-in shapes.",
              "end_connect": "**EXPERIMENTAL** - *The current implementation only works properly\nwith rectangular shapes, such as pictures and rectangles. Use with\nother shape types may cause unexpected visual alignment of the\nconnected end-point and could lead to a load error if cxn_pt_idx\nexceeds the connection point count available on the connected shape.\nThat said, a quick test should reveal what to expect when using this\nmethod with other shape types.*\n\nConnect the ending of this connector to *shape* at the connection\npoint specified by *cxn_pt_idx*.",
              "get_or_add_ln": "Helper method required by |LineFormat|."
            }
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "LineFormat": {
            "type": "class",
            "doc": "Provides access to line properties such as color, style, and width.\n\nA LineFormat object is typically accessed via the ``.line`` property of\na shape such as |Shape| or |Picture|.",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "freeform": {
        "type": "module",
        "doc": "Objects related to construction of freeform shapes.",
        "members": {
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "FreeformBuilder": {
            "type": "class",
            "doc": "Allows a freeform shape to be specified and created.\n\nThe initial pen position is provided on construction. From there, drawing proceeds using\nsuccessive calls to draw line segments. The freeform shape may be closed by calling the\n:meth:`close` method.\n\nA shape may have more than one contour, in which case overlapping areas are \"subtracted\". A\ncontour is a sequence of line segments beginning with a \"move-to\" operation. A move-to\noperation is automatically inserted in each new freeform; additional move-to ops can be\ninserted with the `.move_to()` method.",
            "methods": {
              "add_line_segments": "Add a straight line segment to each point in `vertices`.\n\n`vertices` must be an iterable of (x, y) pairs (2-tuples). Each x and y value is rounded\nto the nearest integer before use. The optional `close` parameter determines whether the\nresulting contour is `closed` or left `open`.\n\nReturns this |FreeformBuilder| object so it can be used in chained calls.",
              "convert_to_shape": "Return new freeform shape positioned relative to specified offset.\n\n`origin_x` and `origin_y` locate the origin of the local coordinate system in slide\ncoordinates (EMU), perhaps most conveniently by use of a |Length| object.\n\nNote that this method may be called more than once to add multiple shapes of the same\ngeometry in different locations on the slide.",
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended.",
              "move_to": "Move pen to (x, y) (local coordinates) without drawing line.\n\nReturns this |FreeformBuilder| object so it can be used in chained calls."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "graphfrm": {
        "type": "module",
        "doc": "Graphic Frame shape and related objects.\n\nA graphic frame is a common container for table, chart, smart art, and media\nobjects.",
        "members": {
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "GraphicFrame": {
            "type": "class",
            "doc": "Container shape for table, chart, smart art, and media objects.\n\nCorresponds to a `p:graphicFrame` element in the shape tree.",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "ParentedElementProxy": {
            "type": "class",
            "doc": "Provides access to ancestor objects and part.\n\nAn ancestor may occasionally be required to provide a service, such as add or drop a\nrelationship. Provides the :attr:`_parent` attribute to subclasses and the public\n:attr:`parent` read-only property.",
            "methods": {}
          },
          "Table": {
            "type": "class",
            "doc": "A DrawingML table object.\n\nNot intended to be constructed directly, use\n:meth:`.Slide.shapes.add_table` to add a table to a slide.",
            "methods": {
              "cell": "Return cell at `row_idx`, `col_idx`.\n\nReturn value is an instance of |_Cell|. `row_idx` and `col_idx` are zero-based, e.g.\ncell(0, 0) is the top, left cell in the table.",
              "iter_cells": "Generate _Cell object for each cell in this table.\n\nEach grid cell is generated in left-to-right, top-to-bottom order.",
              "notify_height_changed": "Called by a row when its height changes.\n\nTriggers the graphic frame to recalculate its total height (as the sum of the row\nheights).",
              "notify_width_changed": "Called by a column when its width changes.\n\nTriggers the graphic frame to recalculate its total width (as the sum of the column\nwidths)."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "group": {
        "type": "module",
        "doc": "GroupShape and related objects.",
        "members": {
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "GroupShape": {
            "type": "class",
            "doc": "A shape that acts as a container for other shapes.",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "ShadowFormat": {
            "type": "class",
            "doc": "Provides access to shadow effect on a shape.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "picture": {
        "type": "module",
        "doc": "Shapes based on the `p:pic` element, including Picture and Movie.",
        "members": {
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "LineFormat": {
            "type": "class",
            "doc": "Provides access to line properties such as color, style, and width.\n\nA LineFormat object is typically accessed via the ``.line`` property of\na shape such as |Shape| or |Picture|.",
            "methods": {}
          },
          "MSO_SHAPE": {
            "type": "class",
            "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
            "methods": {}
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "Movie": {
            "type": "class",
            "doc": "A movie shape, one that places a video on a slide.\n\nLike |Picture|, a movie shape is based on the `p:pic` element. A movie is composed of a video\nand a *poster frame*, the placeholder image that represents the video before it is played.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "PP_MEDIA_TYPE": {
            "type": "class",
            "doc": "Indicates the OLE media type.\n\nExample::\n\n    from pptx.enum.shapes import PP_MEDIA_TYPE\n\n    movie = slide.shapes[0]\n    assert movie.media_type == PP_MEDIA_TYPE.MOVIE\n\nMS API Name: `PpMediaType`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff746008.aspx",
            "methods": {}
          },
          "ParentedElementProxy": {
            "type": "class",
            "doc": "Provides access to ancestor objects and part.\n\nAn ancestor may occasionally be required to provide a service, such as add or drop a\nrelationship. Provides the :attr:`_parent` attribute to subclasses and the public\n:attr:`parent` read-only property.",
            "methods": {}
          },
          "Picture": {
            "type": "class",
            "doc": "A picture shape, one that places an image on a slide.\n\nBased on the `p:pic` element.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "placeholder": {
        "type": "module",
        "doc": "Placeholder-related objects.\n\nSpecific to shapes having a `p:ph` element. A placeholder has distinct behaviors\ndepending on whether it appears on a slide, layout, or master. Hence there is a\nnon-trivial class inheritance structure.",
        "members": {
          "BasePlaceholder": {
            "type": "class",
            "doc": "NOTE: This class is deprecated and will be removed from a future release\nalong with the properties *idx*, *orient*, *ph_type*, and *sz*. The *idx*\nproperty will be available via the .placeholder_format property. The\nothers will be accessed directly from the oxml layer as they are only\nused for internal purposes.\n\nBase class for placeholder subclasses that differentiate the varying\nbehaviors of placeholders on a master, layout, and slide.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "CT_GraphicalObjectFrame": {
            "type": "class",
            "doc": "`p:graphicFrame` element.\n\nA container for a table, a chart, or another graphical object.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_xfrm": "Return the required `p:xfrm` child element.\n\nOverrides version on BaseShapeElement.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Picture": {
            "type": "class",
            "doc": "`p:pic` element.\n\nRepresents a picture shape (an image placement on a slide).",
            "methods": {
              "crop_to_fit": "Set cropping values in `p:blipFill/a:srcRect` such that an image of\n*image_size* will stretch to exactly fit *view_size* when its aspect\nratio is preserved.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_ln": "Return the <a:ln> grandchild element, newly added if not present.",
              "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ChartPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a chart.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_chart": "Return a |PlaceholderGraphicFrame| object containing a new chart of\n*chart_type* depicting *chart_data* and having the same position and\nsize as this placeholder. *chart_type* is one of the\n:ref:`XlChartType` enumeration values. *chart_data* is a |ChartData|\nobject populated with the categories and series values for the chart.\nNote that the new |Chart| object is not returned directly. The chart\nobject may be accessed using the\n:attr:`~.PlaceholderGraphicFrame.chart` property of the returned\n|PlaceholderGraphicFrame| object."
            }
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "GraphicFrame": {
            "type": "class",
            "doc": "Container shape for table, chart, smart art, and media objects.\n\nCorresponds to a `p:graphicFrame` element in the shape tree.",
            "methods": {}
          },
          "LayoutPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide layout.\n\nProvides differentiated behavior for slide layout placeholders, in particular, inheriting\nshape properties from the master placeholder having the same type, when a matching one exists.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "MSO_SHAPE_TYPE": {
            "type": "class",
            "doc": "Specifies the type of a shape, more specifically than the five base types.\n\nAlias: ``MSO``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE_TYPE\n\n    assert shape.type == MSO_SHAPE_TYPE.PICTURE\n\nMS API Name: `MsoShapeType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15).aspx",
            "methods": {}
          },
          "MasterPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide master.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "NotesSlidePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a notes slide. Inherits shape properties from the\nplaceholder on the notes master that has the same type (e.g. 'body').",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "PP_PLACEHOLDER": {
            "type": "class",
            "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
            "methods": {}
          },
          "Picture": {
            "type": "class",
            "doc": "A picture shape, one that places an image on a slide.\n\nBased on the `p:pic` element.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "PicturePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a picture.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_picture": "Return a |PlaceholderPicture| object depicting the image in `image_file`.\n\n`image_file` may be either a path (string) or a file-like object. The image is\ncropped to fill the entire space of the placeholder. A |PlaceholderPicture|\nobject has all the properties and methods of a |Picture| shape except that the\nvalue of its :attr:`~._BaseSlidePlaceholder.shape_type` property is\n`MSO_SHAPE_TYPE.PLACEHOLDER` instead of `MSO_SHAPE_TYPE.PICTURE`."
            }
          },
          "PlaceholderGraphicFrame": {
            "type": "class",
            "doc": "Placeholder shape populated with a table, chart, or smart art.",
            "methods": {}
          },
          "PlaceholderPicture": {
            "type": "class",
            "doc": "Placeholder shape populated with a picture.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "Shape": {
            "type": "class",
            "doc": "A shape that can appear on a slide.\n\nCorresponds to the `p:sp` element that can appear in any of the slide-type parts\n(slide, slideLayout, slideMaster, notesPage, notesMaster, handoutMaster).",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "SlidePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide. Inherits shape properties from its\ncorresponding slide layout placeholder.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "TablePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a table.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_table": "Return |PlaceholderGraphicFrame| object containing a `rows` by `cols` table.\n\nThe position and width of the table are those of the placeholder and its height\nis proportional to the number of rows. A |PlaceholderGraphicFrame| object has\nall the properties and methods of a |GraphicFrame| shape except that the value\nof its :attr:`~._BaseSlidePlaceholder.shape_type` property is unconditionally\n`MSO_SHAPE_TYPE.PLACEHOLDER`. Note that the return value is not the new table\nbut rather *contains* the new table. The table can be accessed using the\n:attr:`~.PlaceholderGraphicFrame.table` property of the returned\n|PlaceholderGraphicFrame| object."
            }
          }
        }
      },
      "shapetree": {
        "type": "module",
        "doc": "The shape tree, the structure that holds a slide's shapes.",
        "members": {
          "AutoShapeType": {
            "type": "class",
            "doc": "Provides access to metadata for an auto-shape of type identified by `autoshape_type_id`.\n\nInstances are cached, so no more than one instance for a particular auto shape type is in\nmemory.\n\nInstances provide the following attributes:\n\n.. attribute:: autoshape_type_id\n\n   Integer uniquely identifying this auto shape type. Corresponds to a\n   value in `pptx.constants.MSO` like `MSO_SHAPE.ROUNDED_RECTANGLE`.\n\n.. attribute:: basename\n\n   Base part of shape name for auto shapes of this type, e.g. `Rounded\n   Rectangle` becomes `Rounded Rectangle 99` when the distinguishing\n   integer is added to the shape name.\n\n.. attribute:: prst\n\n   String identifier for this auto shape type used in the `a:prstGeom`\n   element.",
            "methods": {}
          },
          "BasePlaceholders": {
            "type": "class",
            "doc": "Base class for placeholder collections.\n\nSubclasses differentiate behaviors for a master, layout, and slide. By default, placeholder\nshapes are constructed using |BaseShapeFactory|. Subclasses should override\n:method:`_shape_factory` to use custom placeholder classes.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "BaseShape": {
            "type": "class",
            "doc": "Base class for shape objects.\n\nSubclasses include |Shape|, |Picture|, and |GraphicFrame|.",
            "methods": {}
          },
          "CT": {
            "type": "class",
            "doc": "Content type URIs (like MIME-types) that specify a part's format.",
            "methods": {}
          },
          "CT_GraphicalObjectFrame": {
            "type": "class",
            "doc": "`p:graphicFrame` element.\n\nA container for a table, a chart, or another graphical object.",
            "methods": {
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_xfrm": "Return the required `p:xfrm` child element.\n\nOverrides version on BaseShapeElement.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Picture": {
            "type": "class",
            "doc": "`p:pic` element.\n\nRepresents a picture shape (an image placement on a slide).",
            "methods": {
              "crop_to_fit": "Set cropping values in `p:blipFill/a:srcRect` such that an image of\n*image_size* will stretch to exactly fit *view_size* when its aspect\nratio is preserved.",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_ln": "Return the <a:ln> grandchild element, newly added if not present.",
              "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
              "insert_element_before": "No documentation",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "CT_Shape": {
            "type": "class",
            "doc": "`p:sp` custom element class.",
            "methods": {
              "add_path": "No documentation",
              "first_child_found_in": "First child with tag in `tagnames`, or None if not found.",
              "get_or_add_ln": "Return the `a:ln` grandchild element, newly added if not present.",
              "get_or_add_txBody": "Return the ``<p:txBody>`` child element, newly added if not present.",
              "get_or_add_xfrm": "Return the `a:xfrm` grandchild element, newly-added if not present.\n\nThis version works for `p:sp`, `p:cxnSp`, and `p:pic` elements, others will need to\noverride.",
              "insert_element_before": "No documentation",
              "new_autoshape_sp": "Return a new `p:sp` element tree configured as a base auto shape.",
              "new_freeform_sp": "Return new `p:sp` element tree configured as freeform shape.\n\nThe returned shape has a `a:custGeom` subtree but no paths in its\npath list.",
              "new_placeholder_sp": "Return a new `p:sp` element tree configured as a placeholder shape.",
              "new_textbox_sp": "Return a new `p:sp` element tree configured as a base textbox shape.",
              "remove_all": "Remove child elements with tagname (e.g. \"a:p\") in `tagnames`.",
              "xpath": "Override of `lxml` _Element.xpath() method.\n\nProvides standard Open XML namespace mapping (`nsmap`) in centralized location."
            }
          },
          "ChartPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a chart.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_chart": "Return a |PlaceholderGraphicFrame| object containing a new chart of\n*chart_type* depicting *chart_data* and having the same position and\nsize as this placeholder. *chart_type* is one of the\n:ref:`XlChartType` enumeration values. *chart_data* is a |ChartData|\nobject populated with the categories and series values for the chart.\nNote that the new |Chart| object is not returned directly. The chart\nobject may be accessed using the\n:attr:`~.PlaceholderGraphicFrame.chart` property of the returned\n|PlaceholderGraphicFrame| object."
            }
          },
          "Connector": {
            "type": "class",
            "doc": "Connector (line) shape.\n\nA connector is a linear shape having end-points that can be connected to\nother objects (but not to other connectors). A connector can be straight,\nhave elbows, or can be curved.",
            "methods": {
              "begin_connect": "**EXPERIMENTAL** - *The current implementation only works properly\nwith rectangular shapes, such as pictures and rectangles. Use with\nother shape types may cause unexpected visual alignment of the\nconnected end-point and could lead to a load error if cxn_pt_idx\nexceeds the connection point count available on the connected shape.\nThat said, a quick test should reveal what to expect when using this\nmethod with other shape types.*\n\nConnect the beginning of this connector to *shape* at the connection\npoint specified by *cxn_pt_idx*. Each shape has zero or more\nconnection points and they are identified by index, starting with 0.\nGenerally, the first connection point of a shape is at the top center\nof its bounding box and numbering proceeds counter-clockwise from\nthere. However this is only a convention and may vary, especially\nwith non built-in shapes.",
              "end_connect": "**EXPERIMENTAL** - *The current implementation only works properly\nwith rectangular shapes, such as pictures and rectangles. Use with\nother shape types may cause unexpected visual alignment of the\nconnected end-point and could lead to a load error if cxn_pt_idx\nexceeds the connection point count available on the connected shape.\nThat said, a quick test should reveal what to expect when using this\nmethod with other shape types.*\n\nConnect the ending of this connector to *shape* at the connection\npoint specified by *cxn_pt_idx*.",
              "get_or_add_ln": "Helper method required by |LineFormat|."
            }
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "FreeformBuilder": {
            "type": "class",
            "doc": "Allows a freeform shape to be specified and created.\n\nThe initial pen position is provided on construction. From there, drawing proceeds using\nsuccessive calls to draw line segments. The freeform shape may be closed by calling the\n:meth:`close` method.\n\nA shape may have more than one contour, in which case overlapping areas are \"subtracted\". A\ncontour is a sequence of line segments beginning with a \"move-to\" operation. A move-to\noperation is automatically inserted in each new freeform; additional move-to ops can be\ninserted with the `.move_to()` method.",
            "methods": {
              "add_line_segments": "Add a straight line segment to each point in `vertices`.\n\n`vertices` must be an iterable of (x, y) pairs (2-tuples). Each x and y value is rounded\nto the nearest integer before use. The optional `close` parameter determines whether the\nresulting contour is `closed` or left `open`.\n\nReturns this |FreeformBuilder| object so it can be used in chained calls.",
              "convert_to_shape": "Return new freeform shape positioned relative to specified offset.\n\n`origin_x` and `origin_y` locate the origin of the local coordinate system in slide\ncoordinates (EMU), perhaps most conveniently by use of a |Length| object.\n\nNote that this method may be called more than once to add multiple shapes of the same\ngeometry in different locations on the slide.",
              "count": "S.count(value) -> integer -- return number of occurrences of value",
              "index": "S.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.\n\nSupporting start and stop arguments is optional, but\nrecommended.",
              "move_to": "Move pen to (x, y) (local coordinates) without drawing line.\n\nReturns this |FreeformBuilder| object so it can be used in chained calls."
            }
          },
          "GraphicFrame": {
            "type": "class",
            "doc": "Container shape for table, chart, smart art, and media objects.\n\nCorresponds to a `p:graphicFrame` element in the shape tree.",
            "methods": {}
          },
          "GroupShape": {
            "type": "class",
            "doc": "A shape that acts as a container for other shapes.",
            "methods": {}
          },
          "GroupShapes": {
            "type": "class",
            "doc": "The sequence of child shapes belonging to a group shape.\n\nNote that this collection can itself contain a group shape, making this part of a recursive,\ntree data structure (acyclic graph).",
            "methods": {
              "add_chart": "Add a new chart of `chart_type` to the slide.\n\nThe chart is positioned at (`x`, `y`), has size (`cx`, `cy`), and depicts `chart_data`.\n`chart_type` is one of the :ref:`XlChartType` enumeration values. `chart_data` is a\n|ChartData| object populated with the categories and series values for the chart.\n\nNote that a |GraphicFrame| shape object is returned, not the |Chart| object contained in\nthat graphic frame shape. The chart object may be accessed using the :attr:`chart`\nproperty of the returned |GraphicFrame| object.",
              "add_connector": "Add a newly created connector shape to the end of this shape tree.\n\n`connector_type` is a member of the :ref:`MsoConnectorType` enumeration and the end-point\nvalues are specified as EMU values. The returned connector is of type `connector_type` and\nhas begin and end points as specified.",
              "add_group_shape": "Return a |GroupShape| object newly appended to this shape tree.\n\nThe group shape is empty and must be populated with shapes using methods on its shape\ntree, available on its `.shapes` property. The position and extents of the group shape are\ndetermined by the shapes it contains; its position and extents are recalculated each time\na shape is added to it.",
              "add_ole_object": "Return newly-created GraphicFrame shape embedding `object_file`.\n\nThe returned graphic-frame shape contains `object_file` as an embedded OLE object. It is\ndisplayed as an icon at `left`, `top` with size `width`, `height`. `width` and `height`\nmay be omitted when `prog_id` is a member of `PROG_ID`, in which case the default icon\nsize is used. This is advised for best appearance where applicable because it avoids an\nicon with a \"stretched\" appearance.\n\n`object_file` may either be a str path to a file or file-like object (such as\n`io.BytesIO`) containing the bytes of the object to be embedded (such as an Excel file).\n\n`prog_id` can be either a member of `pptx.enum.shapes.PROG_ID` or a str value like\n`\"Adobe.Exchange.7\"` determined by inspecting the XML generated by PowerPoint for an\nobject of the desired type.\n\n`icon_file` may either be a str path to an image file or a file-like object containing the\nimage. The image provided will be displayed in lieu of the OLE object; double-clicking on\nthe image opens the object (subject to operating-system limitations). The image file can\nbe any supported image file. Those produced by PowerPoint itself are generally EMF and can\nbe harvested from a PPTX package that embeds such an object. PNG and JPG also work fine.\n\n`icon_width` and `icon_height` are `Length` values (e.g. Emu() or Inches()) that describe\nthe size of the icon image within the shape. These should be omitted unless a custom\n`icon_file` is provided. The dimensions must be discovered by inspecting the XML.\nAutomatic resizing of the OLE-object shape can occur when the icon is double-clicked if\nthese values are not as set by PowerPoint. This behavior may only manifest in the Windows\nversion of PowerPoint.",
              "add_picture": "Add picture shape displaying image in `image_file`.\n\n`image_file` can be either a path to a file (a string) or a file-like object. The picture\nis positioned with its top-left corner at (`top`, `left`). If `width` and `height` are\nboth |None|, the native size of the image is used. If only one of `width` or `height` is\nused, the unspecified dimension is calculated to preserve the aspect ratio of the image.\nIf both are specified, the picture is stretched to fit, without regard to its native\naspect ratio.",
              "add_shape": "Return new |Shape| object appended to this shape tree.\n\n`autoshape_type_id` is a member of :ref:`MsoAutoShapeType` e.g. `MSO_SHAPE.RECTANGLE`\nspecifying the type of shape to be added. The remaining arguments specify the new shape's\nposition and size.",
              "add_textbox": "Return newly added text box shape appended to this shape tree.\n\nThe text box is of the specified size, located at the specified position on the slide.",
              "build_freeform": "Return |FreeformBuilder| object to specify a freeform shape.\n\nThe optional `start_x` and `start_y` arguments specify the starting pen position in local\ncoordinates. They will be rounded to the nearest integer before use and each default to\nzero.\n\nThe optional `scale` argument specifies the size of local coordinates proportional to\nslide coordinates (EMU). If the vertical scale is different than the horizontal scale\n(local coordinate units are \"rectangular\"), a pair of numeric values can be provided as\nthe `scale` argument, e.g. `scale=(1.0, 2.0)`. In this case the first number is\ninterpreted as the horizontal (X) scale and the second as the vertical (Y) scale.\n\nA convenient method for calculating scale is to divide a |Length| object by an equivalent\ncount of local coordinate units, e.g. `scale = Inches(1)/1000` for 1000 local units per\ninch.",
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "index": "Return the index of `shape` in this sequence.\n\nRaises |ValueError| if `shape` is not in the collection.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "IO": {
            "type": "class",
            "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "methods": {
              "close": "No documentation",
              "fileno": "No documentation",
              "flush": "No documentation",
              "isatty": "No documentation",
              "read": "No documentation",
              "readable": "No documentation",
              "readline": "No documentation",
              "readlines": "No documentation",
              "seek": "No documentation",
              "seekable": "No documentation",
              "tell": "No documentation",
              "truncate": "No documentation",
              "writable": "No documentation",
              "write": "No documentation",
              "writelines": "No documentation"
            }
          },
          "LayoutPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide layout.\n\nProvides differentiated behavior for slide layout placeholders, in particular, inheriting\nshape properties from the master placeholder having the same type, when a matching one exists.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "LayoutPlaceholders": {
            "type": "class",
            "doc": "Sequence of |LayoutPlaceholder| instance for each placeholder shape on a slide layout.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "get": "The first placeholder shape with matching `idx` value, or `default` if not found.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "LayoutShapes": {
            "type": "class",
            "doc": "Sequence of shapes appearing on a slide layout.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "MasterPlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide master.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "MasterPlaceholders": {
            "type": "class",
            "doc": "Sequence of MasterPlaceholder representing the placeholder shapes on a slide master.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "get": "Return the first placeholder shape with type `ph_type` (e.g. 'body').\n\nReturns `default` if no such placeholder shape is present in the collection.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "MasterShapes": {
            "type": "class",
            "doc": "Sequence of shapes appearing on a slide master.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), and iteration.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "Movie": {
            "type": "class",
            "doc": "A movie shape, one that places a video on a slide.\n\nLike |Picture|, a movie shape is based on the `p:pic` element. A movie is composed of a video\nand a *poster frame*, the placeholder image that represents the video before it is played.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "NotesSlidePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a notes slide. Inherits shape properties from the\nplaceholder on the notes master that has the same type (e.g. 'body').",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "NotesSlidePlaceholders": {
            "type": "class",
            "doc": "Sequence of placeholder shapes on a notes slide.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "get": "Return the first placeholder shape with type `ph_type` (e.g. 'body').\n\nReturns `default` if no such placeholder shape is present in the collection.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "NotesSlideShapes": {
            "type": "class",
            "doc": "Sequence of shapes appearing on a notes slide.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
            "methods": {
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nA notes slide uses a different name for the body placeholder and has some unique\nplaceholder types, so this method overrides the default in the base class."
            }
          },
          "PP_PLACEHOLDER": {
            "type": "class",
            "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
            "methods": {}
          },
          "PROG_ID": {
            "type": "class",
            "doc": "One-off Enum-like object for progId values.\n\nIndicates the type of an OLE object in terms of the program used to open it.\n\nA member of this enumeration can be used in a `SlideShapes.add_ole_object()` call to\nspecify a Microsoft Office file-type (Excel, PowerPoint, or Word), which will\nthen not require several of the arguments required to embed other object types.\n\nExample::\n\n    from pptx.enum.shapes import PROG_ID\n    from pptx.util import Inches\n\n    embedded_xlsx_shape = slide.shapes.add_ole_object(\n        \"workbook.xlsx\", PROG_ID.XLSX, left=Inches(1), top=Inches(1)\n    )\n    assert embedded_xlsx_shape.ole_format.prog_id == \"Excel.Sheet.12\"",
            "methods": {}
          },
          "ParentedElementProxy": {
            "type": "class",
            "doc": "Provides access to ancestor objects and part.\n\nAn ancestor may occasionally be required to provide a service, such as add or drop a\nrelationship. Provides the :attr:`_parent` attribute to subclasses and the public\n:attr:`parent` read-only property.",
            "methods": {}
          },
          "Picture": {
            "type": "class",
            "doc": "A picture shape, one that places an image on a slide.\n\nBased on the `p:pic` element.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "PicturePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a picture.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_picture": "Return a |PlaceholderPicture| object depicting the image in `image_file`.\n\n`image_file` may be either a path (string) or a file-like object. The image is\ncropped to fill the entire space of the placeholder. A |PlaceholderPicture|\nobject has all the properties and methods of a |Picture| shape except that the\nvalue of its :attr:`~._BaseSlidePlaceholder.shape_type` property is\n`MSO_SHAPE_TYPE.PLACEHOLDER` instead of `MSO_SHAPE_TYPE.PICTURE`."
            }
          },
          "PlaceholderGraphicFrame": {
            "type": "class",
            "doc": "Placeholder shape populated with a table, chart, or smart art.",
            "methods": {}
          },
          "PlaceholderPicture": {
            "type": "class",
            "doc": "Placeholder shape populated with a picture.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element for this `p:pic`-based image.\n\nThe `a:ln` element contains the line format properties XML."
            }
          },
          "ST_Direction": {
            "type": "class",
            "doc": "Valid values for `<p:ph orient=\"...\">` attribute.",
            "methods": {}
          },
          "Shape": {
            "type": "class",
            "doc": "A shape that can appear on a slide.\n\nCorresponds to the `p:sp` element that can appear in any of the slide-type parts\n(slide, slideLayout, slideMaster, notesPage, notesMaster, handoutMaster).",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "SlidePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape on a slide. Inherits shape properties from its\ncorresponding slide layout placeholder.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape."
            }
          },
          "SlidePlaceholders": {
            "type": "class",
            "doc": "Collection of placeholder shapes on a slide.\n\nSupports iteration, :func:`len`, and dictionary-style lookup on the `idx` value of the\nplaceholders it contains.",
            "methods": {}
          },
          "SlideShapes": {
            "type": "class",
            "doc": "Sequence of shapes appearing on a slide.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
            "methods": {
              "add_chart": "Add a new chart of `chart_type` to the slide.\n\nThe chart is positioned at (`x`, `y`), has size (`cx`, `cy`), and depicts `chart_data`.\n`chart_type` is one of the :ref:`XlChartType` enumeration values. `chart_data` is a\n|ChartData| object populated with the categories and series values for the chart.\n\nNote that a |GraphicFrame| shape object is returned, not the |Chart| object contained in\nthat graphic frame shape. The chart object may be accessed using the :attr:`chart`\nproperty of the returned |GraphicFrame| object.",
              "add_connector": "Add a newly created connector shape to the end of this shape tree.\n\n`connector_type` is a member of the :ref:`MsoConnectorType` enumeration and the end-point\nvalues are specified as EMU values. The returned connector is of type `connector_type` and\nhas begin and end points as specified.",
              "add_group_shape": "Return a |GroupShape| object newly appended to this shape tree.\n\nThe group shape is empty and must be populated with shapes using methods on its shape\ntree, available on its `.shapes` property. The position and extents of the group shape are\ndetermined by the shapes it contains; its position and extents are recalculated each time\na shape is added to it.",
              "add_movie": "Return newly added movie shape displaying video in `movie_file`.\n\n**EXPERIMENTAL.** This method has important limitations:\n\n* The size must be specified; no auto-scaling such as that provided by :meth:`add_picture`\n  is performed.\n* The MIME type of the video file should be specified, e.g. 'video/mp4'. The provided\n  video file is not interrogated for its type. The MIME type `video/unknown` is used by\n  default (and works fine in tests as of this writing).\n* A poster frame image must be provided, it cannot be automatically extracted from the\n  video file. If no poster frame is provided, the default \"media loudspeaker\" image will\n  be used.\n\nReturn a newly added movie shape to the slide, positioned at (`left`, `top`), having size\n(`width`, `height`), and containing `movie_file`. Before the video is started,\n`poster_frame_image` is displayed as a placeholder for the video.",
              "add_ole_object": "Return newly-created GraphicFrame shape embedding `object_file`.\n\nThe returned graphic-frame shape contains `object_file` as an embedded OLE object. It is\ndisplayed as an icon at `left`, `top` with size `width`, `height`. `width` and `height`\nmay be omitted when `prog_id` is a member of `PROG_ID`, in which case the default icon\nsize is used. This is advised for best appearance where applicable because it avoids an\nicon with a \"stretched\" appearance.\n\n`object_file` may either be a str path to a file or file-like object (such as\n`io.BytesIO`) containing the bytes of the object to be embedded (such as an Excel file).\n\n`prog_id` can be either a member of `pptx.enum.shapes.PROG_ID` or a str value like\n`\"Adobe.Exchange.7\"` determined by inspecting the XML generated by PowerPoint for an\nobject of the desired type.\n\n`icon_file` may either be a str path to an image file or a file-like object containing the\nimage. The image provided will be displayed in lieu of the OLE object; double-clicking on\nthe image opens the object (subject to operating-system limitations). The image file can\nbe any supported image file. Those produced by PowerPoint itself are generally EMF and can\nbe harvested from a PPTX package that embeds such an object. PNG and JPG also work fine.\n\n`icon_width` and `icon_height` are `Length` values (e.g. Emu() or Inches()) that describe\nthe size of the icon image within the shape. These should be omitted unless a custom\n`icon_file` is provided. The dimensions must be discovered by inspecting the XML.\nAutomatic resizing of the OLE-object shape can occur when the icon is double-clicked if\nthese values are not as set by PowerPoint. This behavior may only manifest in the Windows\nversion of PowerPoint.",
              "add_picture": "Add picture shape displaying image in `image_file`.\n\n`image_file` can be either a path to a file (a string) or a file-like object. The picture\nis positioned with its top-left corner at (`top`, `left`). If `width` and `height` are\nboth |None|, the native size of the image is used. If only one of `width` or `height` is\nused, the unspecified dimension is calculated to preserve the aspect ratio of the image.\nIf both are specified, the picture is stretched to fit, without regard to its native\naspect ratio.",
              "add_shape": "Return new |Shape| object appended to this shape tree.\n\n`autoshape_type_id` is a member of :ref:`MsoAutoShapeType` e.g. `MSO_SHAPE.RECTANGLE`\nspecifying the type of shape to be added. The remaining arguments specify the new shape's\nposition and size.",
              "add_table": "Add a |GraphicFrame| object containing a table.\n\nThe table has the specified number of `rows` and `cols` and the specified position and\nsize. `width` is evenly distributed between the columns of the new table. Likewise,\n`height` is evenly distributed between the rows. Note that the `.table` property on the\nreturned |GraphicFrame| shape must be used to access the enclosed |Table| object.",
              "add_textbox": "Return newly added text box shape appended to this shape tree.\n\nThe text box is of the specified size, located at the specified position on the slide.",
              "build_freeform": "Return |FreeformBuilder| object to specify a freeform shape.\n\nThe optional `start_x` and `start_y` arguments specify the starting pen position in local\ncoordinates. They will be rounded to the nearest integer before use and each default to\nzero.\n\nThe optional `scale` argument specifies the size of local coordinates proportional to\nslide coordinates (EMU). If the vertical scale is different than the horizontal scale\n(local coordinate units are \"rectangular\"), a pair of numeric values can be provided as\nthe `scale` argument, e.g. `scale=(1.0, 2.0)`. In this case the first number is\ninterpreted as the horizontal (X) scale and the second as the vertical (Y) scale.\n\nA convenient method for calculating scale is to divide a |Length| object by an equivalent\ncount of local coordinate units, e.g. `scale = Inches(1)/1000` for 1000 local units per\ninch.",
              "clone_layout_placeholders": "Add placeholder shapes based on those in `slide_layout`.\n\nZ-order of placeholders is preserved. Latent placeholders (date, slide number, and footer)\nare not cloned.",
              "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
              "index": "Return the index of `shape` in this sequence.\n\nRaises |ValueError| if `shape` is not in the collection.",
              "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
            }
          },
          "TablePlaceholder": {
            "type": "class",
            "doc": "Placeholder shape that can only accept a table.",
            "methods": {
              "get_or_add_ln": "Return the `a:ln` element containing the line format properties XML for this shape.",
              "insert_table": "Return |PlaceholderGraphicFrame| object containing a `rows` by `cols` table.\n\nThe position and width of the table are those of the placeholder and its height\nis proportional to the number of rows. A |PlaceholderGraphicFrame| object has\nall the properties and methods of a |GraphicFrame| shape except that the value\nof its :attr:`~._BaseSlidePlaceholder.shape_type` property is unconditionally\n`MSO_SHAPE_TYPE.PLACEHOLDER`. Note that the return value is not the new table\nbut rather *contains* the new table. The table can be accessed using the\n:attr:`~.PlaceholderGraphicFrame.table` property of the returned\n|PlaceholderGraphicFrame| object."
            }
          },
          "Video": {
            "type": "class",
            "doc": "Immutable value object representing a video such as MP4.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      }
    }
  },
  "shared": {
    "type": "module",
    "doc": "Objects shared by pptx modules.",
    "members": {
      "ElementProxy": {
        "type": "class",
        "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
        "methods": {}
      },
      "ParentedElementProxy": {
        "type": "class",
        "doc": "Provides access to ancestor objects and part.\n\nAn ancestor may occasionally be required to provide a service, such as add or drop a\nrelationship. Provides the :attr:`_parent` attribute to subclasses and the public\n:attr:`parent` read-only property.",
        "methods": {}
      },
      "PartElementProxy": {
        "type": "class",
        "doc": "Provides common members for proxy-objects that wrap a part's root element, e.g. `p:sld`.",
        "methods": {}
      }
    }
  },
  "slide": {
    "type": "module",
    "doc": "Slide-related objects, including masters, layouts, and notes.",
    "members": {
      "ElementProxy": {
        "type": "class",
        "doc": "Base class for lxml element proxy classes.\n\nAn element proxy class is one whose primary responsibilities are fulfilled by manipulating the\nattributes and child elements of an XML element. They are the most common type of class in\npython-pptx other than custom element (oxml) classes.",
        "methods": {}
      },
      "FillFormat": {
        "type": "class",
        "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
        "methods": {
          "background": "Sets the fill type to noFill, i.e. transparent.",
          "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
          "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
          "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
        }
      },
      "LayoutPlaceholders": {
        "type": "class",
        "doc": "Sequence of |LayoutPlaceholder| instance for each placeholder shape on a slide layout.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "get": "The first placeholder shape with matching `idx` value, or `default` if not found.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "LayoutShapes": {
        "type": "class",
        "doc": "Sequence of shapes appearing on a slide layout.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "MasterPlaceholders": {
        "type": "class",
        "doc": "Sequence of MasterPlaceholder representing the placeholder shapes on a slide master.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "get": "Return the first placeholder shape with type `ph_type` (e.g. 'body').\n\nReturns `default` if no such placeholder shape is present in the collection.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "MasterShapes": {
        "type": "class",
        "doc": "Sequence of shapes appearing on a slide master.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), and iteration.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "NotesMaster": {
        "type": "class",
        "doc": "Proxy for the notes master XML document.\n\nProvides access to shapes, the most commonly used of which are placeholders.",
        "methods": {}
      },
      "NotesSlide": {
        "type": "class",
        "doc": "Notes slide object.\n\nProvides access to slide notes placeholder and other shapes on the notes handout\npage.",
        "methods": {
          "clone_master_placeholders": "Selectively add placeholder shape elements from `notes_master`.\n\nSelected placeholder shape elements from `notes_master` are added to the shapes\ncollection of this notes slide. Z-order of placeholders is preserved. Certain\nplaceholders (header, date, footer) are not cloned."
        }
      },
      "NotesSlidePlaceholders": {
        "type": "class",
        "doc": "Sequence of placeholder shapes on a notes slide.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "get": "Return the first placeholder shape with type `ph_type` (e.g. 'body').\n\nReturns `default` if no such placeholder shape is present in the collection.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "NotesSlideShapes": {
        "type": "class",
        "doc": "Sequence of shapes appearing on a notes slide.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
        "methods": {
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nA notes slide uses a different name for the body placeholder and has some unique\nplaceholder types, so this method overrides the default in the base class."
        }
      },
      "PP_PLACEHOLDER": {
        "type": "class",
        "doc": "Specifies one of the 18 distinct types of placeholder.\n\nAlias: ``PP_PLACEHOLDER``\n\nExample::\n\n    from pptx.enum.shapes import PP_PLACEHOLDER\n\n    placeholder = slide.placeholders[0]\n    assert placeholder.type == PP_PLACEHOLDER.TITLE\n\nMS API name: `PpPlaceholderType`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15 \").aspx\"",
        "methods": {}
      },
      "ParentedElementProxy": {
        "type": "class",
        "doc": "Provides access to ancestor objects and part.\n\nAn ancestor may occasionally be required to provide a service, such as add or drop a\nrelationship. Provides the :attr:`_parent` attribute to subclasses and the public\n:attr:`parent` read-only property.",
        "methods": {}
      },
      "PartElementProxy": {
        "type": "class",
        "doc": "Provides common members for proxy-objects that wrap a part's root element, e.g. `p:sld`.",
        "methods": {}
      },
      "Slide": {
        "type": "class",
        "doc": "Slide object. Provides access to shapes and slide-level properties.",
        "methods": {}
      },
      "SlideLayout": {
        "type": "class",
        "doc": "Slide layout object.\n\nProvides access to placeholders, regular shapes, and slide layout-level properties.",
        "methods": {
          "iter_cloneable_placeholders": "Generate layout-placeholders on this slide-layout that should be cloned to a new slide.\n\nUsed when creating a new slide from this slide-layout."
        }
      },
      "SlideLayouts": {
        "type": "class",
        "doc": "Sequence of slide layouts belonging to a slide-master.\n\nSupports indexed access, len(), iteration, index() and remove().",
        "methods": {
          "get_by_name": "Return SlideLayout object having `name`, or `default` if not found.",
          "index": "Return zero-based index of `slide_layout` in this collection.\n\nRaises `ValueError` if `slide_layout` is not present in this collection.",
          "remove": "Remove `slide_layout` from the collection.\n\nRaises ValueError when `slide_layout` is in use; a slide layout which is the basis for one\nor more slides cannot be removed."
        }
      },
      "SlideMaster": {
        "type": "class",
        "doc": "Slide master object.\n\nProvides access to slide layouts. Access to placeholders, regular shapes, and slide master-level\nproperties is inherited from |_BaseMaster|.",
        "methods": {}
      },
      "SlideMasters": {
        "type": "class",
        "doc": "Sequence of |SlideMaster| objects belonging to a presentation.\n\nHas list access semantics, supporting indexed access, len(), and iteration.",
        "methods": {}
      },
      "SlidePlaceholders": {
        "type": "class",
        "doc": "Collection of placeholder shapes on a slide.\n\nSupports iteration, :func:`len`, and dictionary-style lookup on the `idx` value of the\nplaceholders it contains.",
        "methods": {}
      },
      "SlideShapes": {
        "type": "class",
        "doc": "Sequence of shapes appearing on a slide.\n\nThe first shape in the sequence is the backmost in z-order and the last shape is topmost.\nSupports indexed access, len(), index(), and iteration.",
        "methods": {
          "add_chart": "Add a new chart of `chart_type` to the slide.\n\nThe chart is positioned at (`x`, `y`), has size (`cx`, `cy`), and depicts `chart_data`.\n`chart_type` is one of the :ref:`XlChartType` enumeration values. `chart_data` is a\n|ChartData| object populated with the categories and series values for the chart.\n\nNote that a |GraphicFrame| shape object is returned, not the |Chart| object contained in\nthat graphic frame shape. The chart object may be accessed using the :attr:`chart`\nproperty of the returned |GraphicFrame| object.",
          "add_connector": "Add a newly created connector shape to the end of this shape tree.\n\n`connector_type` is a member of the :ref:`MsoConnectorType` enumeration and the end-point\nvalues are specified as EMU values. The returned connector is of type `connector_type` and\nhas begin and end points as specified.",
          "add_group_shape": "Return a |GroupShape| object newly appended to this shape tree.\n\nThe group shape is empty and must be populated with shapes using methods on its shape\ntree, available on its `.shapes` property. The position and extents of the group shape are\ndetermined by the shapes it contains; its position and extents are recalculated each time\na shape is added to it.",
          "add_movie": "Return newly added movie shape displaying video in `movie_file`.\n\n**EXPERIMENTAL.** This method has important limitations:\n\n* The size must be specified; no auto-scaling such as that provided by :meth:`add_picture`\n  is performed.\n* The MIME type of the video file should be specified, e.g. 'video/mp4'. The provided\n  video file is not interrogated for its type. The MIME type `video/unknown` is used by\n  default (and works fine in tests as of this writing).\n* A poster frame image must be provided, it cannot be automatically extracted from the\n  video file. If no poster frame is provided, the default \"media loudspeaker\" image will\n  be used.\n\nReturn a newly added movie shape to the slide, positioned at (`left`, `top`), having size\n(`width`, `height`), and containing `movie_file`. Before the video is started,\n`poster_frame_image` is displayed as a placeholder for the video.",
          "add_ole_object": "Return newly-created GraphicFrame shape embedding `object_file`.\n\nThe returned graphic-frame shape contains `object_file` as an embedded OLE object. It is\ndisplayed as an icon at `left`, `top` with size `width`, `height`. `width` and `height`\nmay be omitted when `prog_id` is a member of `PROG_ID`, in which case the default icon\nsize is used. This is advised for best appearance where applicable because it avoids an\nicon with a \"stretched\" appearance.\n\n`object_file` may either be a str path to a file or file-like object (such as\n`io.BytesIO`) containing the bytes of the object to be embedded (such as an Excel file).\n\n`prog_id` can be either a member of `pptx.enum.shapes.PROG_ID` or a str value like\n`\"Adobe.Exchange.7\"` determined by inspecting the XML generated by PowerPoint for an\nobject of the desired type.\n\n`icon_file` may either be a str path to an image file or a file-like object containing the\nimage. The image provided will be displayed in lieu of the OLE object; double-clicking on\nthe image opens the object (subject to operating-system limitations). The image file can\nbe any supported image file. Those produced by PowerPoint itself are generally EMF and can\nbe harvested from a PPTX package that embeds such an object. PNG and JPG also work fine.\n\n`icon_width` and `icon_height` are `Length` values (e.g. Emu() or Inches()) that describe\nthe size of the icon image within the shape. These should be omitted unless a custom\n`icon_file` is provided. The dimensions must be discovered by inspecting the XML.\nAutomatic resizing of the OLE-object shape can occur when the icon is double-clicked if\nthese values are not as set by PowerPoint. This behavior may only manifest in the Windows\nversion of PowerPoint.",
          "add_picture": "Add picture shape displaying image in `image_file`.\n\n`image_file` can be either a path to a file (a string) or a file-like object. The picture\nis positioned with its top-left corner at (`top`, `left`). If `width` and `height` are\nboth |None|, the native size of the image is used. If only one of `width` or `height` is\nused, the unspecified dimension is calculated to preserve the aspect ratio of the image.\nIf both are specified, the picture is stretched to fit, without regard to its native\naspect ratio.",
          "add_shape": "Return new |Shape| object appended to this shape tree.\n\n`autoshape_type_id` is a member of :ref:`MsoAutoShapeType` e.g. `MSO_SHAPE.RECTANGLE`\nspecifying the type of shape to be added. The remaining arguments specify the new shape's\nposition and size.",
          "add_table": "Add a |GraphicFrame| object containing a table.\n\nThe table has the specified number of `rows` and `cols` and the specified position and\nsize. `width` is evenly distributed between the columns of the new table. Likewise,\n`height` is evenly distributed between the rows. Note that the `.table` property on the\nreturned |GraphicFrame| shape must be used to access the enclosed |Table| object.",
          "add_textbox": "Return newly added text box shape appended to this shape tree.\n\nThe text box is of the specified size, located at the specified position on the slide.",
          "build_freeform": "Return |FreeformBuilder| object to specify a freeform shape.\n\nThe optional `start_x` and `start_y` arguments specify the starting pen position in local\ncoordinates. They will be rounded to the nearest integer before use and each default to\nzero.\n\nThe optional `scale` argument specifies the size of local coordinates proportional to\nslide coordinates (EMU). If the vertical scale is different than the horizontal scale\n(local coordinate units are \"rectangular\"), a pair of numeric values can be provided as\nthe `scale` argument, e.g. `scale=(1.0, 2.0)`. In this case the first number is\ninterpreted as the horizontal (X) scale and the second as the vertical (Y) scale.\n\nA convenient method for calculating scale is to divide a |Length| object by an equivalent\ncount of local coordinate units, e.g. `scale = Inches(1)/1000` for 1000 local units per\ninch.",
          "clone_layout_placeholders": "Add placeholder shapes based on those in `slide_layout`.\n\nZ-order of placeholders is preserved. Latent placeholders (date, slide number, and footer)\nare not cloned.",
          "clone_placeholder": "Add a new placeholder shape based on `placeholder`.",
          "index": "Return the index of `shape` in this sequence.\n\nRaises |ValueError| if `shape` is not in the collection.",
          "ph_basename": "Return the base name for a placeholder of `ph_type` in this shape collection.\n\nThere is some variance between slide types, for example a notes slide uses a different\nname for the body placeholder, so this method can be overriden by subclasses."
        }
      },
      "Slides": {
        "type": "class",
        "doc": "Sequence of slides belonging to an instance of |Presentation|.\n\nHas list semantics for access to individual slides. Supports indexed access, len(), and\niteration.",
        "methods": {
          "add_slide": "Return a newly added slide that inherits layout from `slide_layout`.",
          "get": "Return the slide identified by int `slide_id` in this presentation.\n\nReturns `default` if not found.",
          "index": "Map `slide` to its zero-based position in this slide sequence.\n\nRaises |ValueError| on *slide* not present."
        }
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "spec": {
    "type": "module",
    "doc": "Mappings from the ISO/IEC 29500 spec.\n\nSome of these are inferred from PowerPoint application behavior",
    "members": {
      "MSO_SHAPE": {
        "type": "class",
        "doc": "Specifies a type of AutoShape, e.g. DOWN_ARROW.\n\nAlias: ``MSO_SHAPE``\n\nExample::\n\n    from pptx.enum.shapes import MSO_SHAPE\n    from pptx.util import Inches\n\n    left = top = width = height = Inches(1.0)\n    slide.shapes.add_shape(\n        MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height\n    )\n\nMS API Name: `MsoAutoShapeType`\n\nhttps://learn.microsoft.com/en-us/office/vba/api/Office.MsoAutoShapeType",
        "methods": {}
      },
      "ShapeSpec": {
        "type": "class",
        "doc": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
        "methods": {}
      }
    }
  },
  "table": {
    "type": "module",
    "doc": "Table-related objects such as Table and Cell.",
    "members": {
      "Emu": {
        "type": "class",
        "doc": "Convenience constructor for length in english metric units.",
        "methods": {}
      },
      "FillFormat": {
        "type": "class",
        "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
        "methods": {
          "background": "Sets the fill type to noFill, i.e. transparent.",
          "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
          "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
          "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
        }
      },
      "Subshape": {
        "type": "class",
        "doc": "Provides access to the containing part for drawing elements that occur below a shape.\n\nAccess to the part is required for example to add or drop a relationship. Provides\n`self._parent` attribute to subclasses.",
        "methods": {}
      },
      "Table": {
        "type": "class",
        "doc": "A DrawingML table object.\n\nNot intended to be constructed directly, use\n:meth:`.Slide.shapes.add_table` to add a table to a slide.",
        "methods": {
          "cell": "Return cell at `row_idx`, `col_idx`.\n\nReturn value is an instance of |_Cell|. `row_idx` and `col_idx` are zero-based, e.g.\ncell(0, 0) is the top, left cell in the table.",
          "iter_cells": "Generate _Cell object for each cell in this table.\n\nEach grid cell is generated in left-to-right, top-to-bottom order.",
          "notify_height_changed": "Called by a row when its height changes.\n\nTriggers the graphic frame to recalculate its total height (as the sum of the row\nheights).",
          "notify_width_changed": "Called by a column when its width changes.\n\nTriggers the graphic frame to recalculate its total width (as the sum of the column\nwidths)."
        }
      },
      "TcRange": {
        "type": "class",
        "doc": "A 2D block of `a:tc` cell elements in a table.\n\nThis object assumes the structure of the underlying table does not change during its lifetime.\nStructural changes in this context would be insertion or removal of rows or columns.\n\nThe client is expected to create, use, and then abandon an instance in the context of a single\nuser operation that is known to have no structural side-effects of this type.",
        "methods": {
          "iter_except_left_col_tcs": "Generate each `a:tc` element not in leftmost column of range.",
          "iter_except_top_row_tcs": "Generate each `a:tc` element in non-first rows of range.",
          "iter_left_col_tcs": "Generate each `a:tc` element in leftmost column of range.",
          "iter_tcs": "Generate each `a:tc` element in this range.\n\nCell elements are generated left-to-right, top-to-bottom.",
          "iter_top_row_tcs": "Generate each `a:tc` element in topmost row of range.",
          "move_content_to_origin": "Move all paragraphs in range to origin cell."
        }
      },
      "TextFrame": {
        "type": "class",
        "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
        "methods": {
          "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
          "clear": "Remove all paragraphs except one empty one.",
          "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
        }
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  },
  "text": {
    "type": "module",
    "doc": "No documentation",
    "members": {
      "fonts": {
        "type": "module",
        "doc": "Objects related to system font file lookup.",
        "members": {
          "FontFiles": {
            "type": "class",
            "doc": "A class-based singleton serving as a lazy cache for system font details.",
            "methods": {}
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      },
      "layout": {
        "type": "module",
        "doc": "Objects related to layout of rendered text, such as TextFitter.",
        "members": {
          "TextFitter": {
            "type": "class",
            "doc": "Value object that knows how to fit text into given rectangular extents.",
            "methods": {}
          }
        }
      },
      "text": {
        "type": "module",
        "doc": "Text-related objects such as TextFrame and Paragraph.",
        "members": {
          "Centipoints": {
            "type": "class",
            "doc": "Convenience constructor for length in hundredths of a point.",
            "methods": {}
          },
          "Emu": {
            "type": "class",
            "doc": "Convenience constructor for length in english metric units.",
            "methods": {}
          },
          "FillFormat": {
            "type": "class",
            "doc": "Provides access to the current fill properties.\n\nAlso provides methods to change the fill type.",
            "methods": {
              "background": "Sets the fill type to noFill, i.e. transparent.",
              "gradient": "Sets the fill type to gradient.\n\nIf the fill is not already a gradient, a default gradient is added.\nThe default gradient corresponds to the default in the built-in\nPowerPoint \"White\" template. This gradient is linear at angle\n90-degrees (upward), with two stops. The first stop is Accent-1 with\ntint 100%, shade 100%, and satMod 130%. The second stop is Accent-1\nwith tint 50%, shade 100%, and satMod 350%.",
              "patterned": "Selects the pattern fill type.\n\nNote that calling this method does not by itself set a foreground or\nbackground color of the pattern. Rather it enables subsequent\nassignments to properties like fore_color to set the pattern and\ncolors.",
              "solid": "Sets the fill type to solid, i.e. a solid color. Note that calling\nthis method does not set a color or by itself cause the shape to\nappear with a solid color fill; rather it enables subsequent\nassignments to properties like fore_color to set the color."
            }
          },
          "Font": {
            "type": "class",
            "doc": "Character properties object, providing font size, font name, bold, italic, etc.\n\nCorresponds to `a:rPr` child element of a run. Also appears as `a:defRPr` and\n`a:endParaRPr` in paragraph and `a:defRPr` in list style elements.",
            "methods": {}
          },
          "FontFiles": {
            "type": "class",
            "doc": "A class-based singleton serving as a lazy cache for system font details.",
            "methods": {}
          },
          "Length": {
            "type": "class",
            "doc": "Base class for length classes Inches, Emu, Cm, Mm, and Pt.\n\nProvides properties for converting length values to convenient units.",
            "methods": {}
          },
          "MSO_AUTO_SIZE": {
            "type": "class",
            "doc": "Determines the type of automatic sizing allowed.\n\nThe following names can be used to specify the automatic sizing behavior used to fit a shape's\ntext within the shape bounding box, for example::\n\n    from pptx.enum.text import MSO_AUTO_SIZE\n\n    shape.text_frame.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE\n\nThe word-wrap setting of the text frame interacts with the auto-size setting to determine the\nspecific auto-sizing behavior.\n\nNote that `TextFrame.auto_size` can also be set to |None|, which removes the auto size setting\naltogether. This causes the setting to be inherited, either from the layout placeholder, in the\ncase of a placeholder shape, or from the theme.\n\nMS API Name: `MsoAutoSize`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865367(v=office.15).aspx",
            "methods": {}
          },
          "MSO_FILL": {
            "type": "class",
            "doc": "Specifies the type of bitmap used for the fill of a shape.\n\nAlias: ``MSO_FILL``\n\nExample::\n\n    from pptx.enum.dml import MSO_FILL\n\n    assert shape.fill.type == MSO_FILL.SOLID\n\nMS API Name: `MsoFillType`\n\nhttp://msdn.microsoft.com/EN-US/library/office/ff861408.aspx",
            "methods": {}
          },
          "MSO_LANGUAGE_ID": {
            "type": "class",
            "doc": "Specifies the language identifier.\n\nExample::\n\n    from pptx.enum.lang import MSO_LANGUAGE_ID\n\n    font.language_id = MSO_LANGUAGE_ID.POLISH\n\nMS API Name: `MsoLanguageId`\n\nhttps://msdn.microsoft.com/en-us/library/office/ff862134.aspx",
            "methods": {}
          },
          "MSO_UNDERLINE": {
            "type": "class",
            "doc": "Indicates the type of underline for text. Used with\n:attr:`.Font.underline` to specify the style of text underlining.\n\nAlias: ``MSO_UNDERLINE``\n\nExample::\n\n    from pptx.enum.text import MSO_UNDERLINE\n\n    run.font.underline = MSO_UNDERLINE.DOUBLE_LINE\n\nMS API Name: `MsoTextUnderlineType`\n\nhttp://msdn.microsoft.com/en-us/library/aa432699.aspx",
            "methods": {}
          },
          "MSO_VERTICAL_ANCHOR": {
            "type": "class",
            "doc": "Specifies the vertical alignment of text in a text frame.\n\nUsed with the `.vertical_anchor` property of the |TextFrame| object. Note that the\n`vertical_anchor` property can also have the value None, indicating there is no directly\nspecified vertical anchor setting and its effective value is inherited from its placeholder if\nit has one or from the theme. |None| may also be assigned to remove an explicitly specified\nvertical anchor setting.\n\nMS API Name: `MsoVerticalAnchor`\n\nhttp://msdn.microsoft.com/en-us/library/office/ff865255.aspx",
            "methods": {}
          },
          "Pt": {
            "type": "class",
            "doc": "Convenience value class for specifying a length in points.",
            "methods": {}
          },
          "RT": {
            "type": "class",
            "doc": "No documentation",
            "methods": {}
          },
          "ST_TextWrappingType": {
            "type": "class",
            "doc": "Valid values for <a:bodyPr wrap=\"\"> attribute",
            "methods": {}
          },
          "Subshape": {
            "type": "class",
            "doc": "Provides access to the containing part for drawing elements that occur below a shape.\n\nAccess to the part is required for example to add or drop a relationship. Provides\n`self._parent` attribute to subclasses.",
            "methods": {}
          },
          "TextFitter": {
            "type": "class",
            "doc": "Value object that knows how to fit text into given rectangular extents.",
            "methods": {}
          },
          "TextFrame": {
            "type": "class",
            "doc": "The part of a shape that contains its text.\n\nNot all shapes have a text frame. Corresponds to the `p:txBody` element that can\nappear as a child element of `p:sp`. Not intended to be constructed directly.",
            "methods": {
              "add_paragraph": "Return new |_Paragraph| instance appended to the sequence of\nparagraphs contained in this text frame.",
              "clear": "Remove all paragraphs except one empty one.",
              "fit_text": "Fit text-frame text entirely within bounds of its shape.\n\nMake the text in this text frame fit entirely within the bounds of its shape by setting\nword wrap on and applying the \"best-fit\" font size to all the text it contains.\n\n:attr:`TextFrame.auto_size` is set to :attr:`MSO_AUTO_SIZE.NONE`. The font size will not\nbe set larger than `max_size` points. If the path to a matching TrueType font is provided\nas `font_file`, that font file will be used for the font metrics. If `font_file` is |None|,\nbest efforts are made to locate a font file with matchhing `font_family`, `bold`, and\n`italic` installed on the current system (usually succeeds if the font is installed)."
            }
          },
          "lazyproperty": {
            "type": "class",
            "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
            "methods": {}
          }
        }
      }
    }
  },
  "util": {
    "type": "module",
    "doc": "Utility functions and classes.",
    "members": {
      "Centipoints": {
        "type": "class",
        "doc": "Convenience constructor for length in hundredths of a point.",
        "methods": {}
      },
      "Cm": {
        "type": "class",
        "doc": "Convenience constructor for length in centimeters.",
        "methods": {}
      },
      "Emu": {
        "type": "class",
        "doc": "Convenience constructor for length in english metric units.",
        "methods": {}
      },
      "Generic": {
        "type": "class",
        "doc": "Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
        "methods": {}
      },
      "Inches": {
        "type": "class",
        "doc": "Convenience constructor for length in inches.",
        "methods": {}
      },
      "Length": {
        "type": "class",
        "doc": "Base class for length classes Inches, Emu, Cm, Mm, and Pt.\n\nProvides properties for converting length values to convenient units.",
        "methods": {}
      },
      "Mm": {
        "type": "class",
        "doc": "Convenience constructor for length in millimeters.",
        "methods": {}
      },
      "Pt": {
        "type": "class",
        "doc": "Convenience value class for specifying a length in points.",
        "methods": {}
      },
      "TypeVar": {
        "type": "class",
        "doc": "Type variable.\n\nUsage::\n\n  T = TypeVar('T')  # Can be anything\n  A = TypeVar('A', str, bytes)  # Must be str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function definitions.  See class Generic for more\ninformation on generic types.  Generic functions work as follows:\n\n  def repeat(x: T, n: int) -> List[T]:\n      '''Return a list containing n references to x.'''\n      return [x]*n\n\n  def longest(x: A, y: A) -> A:\n      '''Return the longest of two strings.'''\n      return x if len(x) >= len(y) else y\n\nThe latter example's signature is essentially the overloading\nof (str, str) -> str and (bytes, bytes) -> bytes.  Also note\nthat if the arguments are instances of some subclass of str,\nthe return type is still plain str.\n\nAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\nType variables defined with covariant=True or contravariant=True\ncan be used to declare covariant or contravariant generic types.\nSee PEP 484 for more details. By default generic types are invariant\nin all type variables.\n\nType variables can be introspected. e.g.:\n\n  T.__name__ == 'T'\n  T.__constraints__ == ()\n  T.__covariant__ == False\n  T.__contravariant__ = False\n  A.__constraints__ == (str, bytes)\n\nNote that only type variables defined in global scope can be pickled.",
        "methods": {}
      },
      "lazyproperty": {
        "type": "class",
        "doc": "Decorator like @property, but evaluated only on first access.\n\nLike @property, this can only be used to decorate methods having only a `self` parameter, and\nis accessed like an attribute on an instance, i.e. trailing parentheses are not used. Unlike\n@property, the decorated method is only evaluated on first access; the resulting value is\ncached and that same value returned on second and later access without re-evaluation of the\nmethod.\n\nLike @property, this class produces a *data descriptor* object, which is stored in the __dict__\nof the *class* under the name of the decorated method ('fget' nominally). The cached value is\nstored in the __dict__ of the *instance* under that same name.\n\nBecause it is a data descriptor (as opposed to a *non-data descriptor*), its `__get__()` method\nis executed on each access of the decorated attribute; the __dict__ item of the same name is\n\"shadowed\" by the descriptor.\n\nWhile this may represent a performance improvement over a property, its greater benefit may be\nits other characteristics. One common use is to construct collaborator objects, removing that\n\"real work\" from the constructor, while still only executing once. It also de-couples client\ncode from any sequencing considerations; if it's accessed from more than one location, it's\nassured it will be ready whenever needed.\n\nLoosely based on: https://stackoverflow.com/a/6849299/1902513.\n\nA lazyproperty is read-only. There is no counterpart to the optional \"setter\" (or deleter)\nbehavior of an @property. This is critically important to maintaining its immutability and\nidempotence guarantees. Attempting to assign to a lazyproperty raises AttributeError\nunconditionally.\n\nThe parameter names in the methods below correspond to this usage example::\n\n    class Obj(object)\n\n        @lazyproperty\n        def fget(self):\n            return 'some result'\n\n    obj = Obj()\n\nNot suitable for wrapping a function (as opposed to a method) because it is not callable.",
        "methods": {}
      }
    }
  }
}